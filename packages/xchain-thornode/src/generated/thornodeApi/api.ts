/* tslint:disable */
/* eslint-disable */
/**
 * Thornode API
 * Thornode REST API.
 *
 * The version of the OpenAPI document: 1.89.0
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BanResponse
 */
export interface BanResponse {
    /**
     * 
     * @type {string}
     * @memberof BanResponse
     */
    'node_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof BanResponse
     */
    'block_height'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BanResponse
     */
    'signers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ChainHeight
 */
export interface ChainHeight {
    /**
     * 
     * @type {string}
     * @memberof ChainHeight
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof ChainHeight
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    'amount': string;
    /**
     * 
     * @type {number}
     * @memberof Coin
     */
    'decimals'?: number;
}
/**
 * 
 * @export
 * @interface ConstantsResponse
 */
export interface ConstantsResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'int64_values'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'bool_values'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'string_values'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface KeysignInfo
 */
export interface KeysignInfo {
    /**
     * the block(s) in which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue
     * @type {number}
     * @memberof KeysignInfo
     */
    'height'?: number;
    /**
     * 
     * @type {Array<TxOutItem>}
     * @memberof KeysignInfo
     */
    'tx_array': Array<TxOutItem>;
}
/**
 * 
 * @export
 * @interface KeysignMetrics
 */
export interface KeysignMetrics {
    /**
     * 
     * @type {string}
     * @memberof KeysignMetrics
     */
    'tx_id'?: string;
    /**
     * 
     * @type {Array<TssMetric>}
     * @memberof KeysignMetrics
     */
    'node_tss_times'?: Array<TssMetric>;
}
/**
 * 
 * @export
 * @interface KeysignResponse
 */
export interface KeysignResponse {
    /**
     * 
     * @type {KeysignInfo}
     * @memberof KeysignResponse
     */
    'keysign'?: KeysignInfo;
    /**
     * 
     * @type {string}
     * @memberof KeysignResponse
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface LastBlock
 */
export interface LastBlock {
    /**
     * 
     * @type {string}
     * @memberof LastBlock
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'last_observed_in': number;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'last_signed_out': number;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'thorchain': number;
}
/**
 * 
 * @export
 * @interface LiquidityProvider
 */
export interface LiquidityProvider {
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'rune_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_add_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_withdraw_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'units': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_rune': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_tx_Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'rune_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_deposit_value': string;
}
/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * 
     * @type {Array<object>}
     * @memberof MetricsResponse
     */
    'keygen'?: Array<object>;
    /**
     * 
     * @type {KeysignMetrics}
     * @memberof MetricsResponse
     */
    'keysign'?: KeysignMetrics;
}
/**
 * 
 * @export
 * @interface MimirNodesResponse
 */
export interface MimirNodesResponse {
    /**
     * 
     * @type {Array<MimirVote>}
     * @memberof MimirNodesResponse
     */
    'mimirs'?: Array<MimirVote>;
}
/**
 * 
 * @export
 * @interface MimirVote
 */
export interface MimirVote {
    /**
     * 
     * @type {string}
     * @memberof MimirVote
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof MimirVote
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof MimirVote
     */
    'signer'?: string;
}
/**
 * 
 * @export
 * @interface NetworkResponse
 */
export interface NetworkResponse {
    /**
     * total amount of RUNE awarded to node operators
     * @type {string}
     * @memberof NetworkResponse
     */
    'bond_reward_rune': string;
    /**
     * total bonded RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_bond_units': string;
    /**
     * total reserve RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_reserve': string;
    /**
     * total of burned BEP2 RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'burned_bep_2_rune': string;
    /**
     * total of burned ERC20 RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'burned_erc_20_rune': string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'node_address': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'status': NodeStatusEnum;
    /**
     * 
     * @type {NodePubKeySet}
     * @memberof Node
     */
    'pub_key_set': NodePubKeySet;
    /**
     * the consensus pub key for the node
     * @type {string}
     * @memberof Node
     */
    'validator_cons_pub_key': string;
    /**
     * current node bond
     * @type {string}
     * @memberof Node
     */
    'bond': string;
    /**
     * the block height at which the node became active
     * @type {number}
     * @memberof Node
     */
    'active_block_height': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'bond_address': string;
    /**
     * the block height of the current provided information for the node
     * @type {number}
     * @memberof Node
     */
    'status_since': number;
    /**
     * the set of vault public keys of which the node is a member
     * @type {Array<string>}
     * @memberof Node
     */
    'signer_membership': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Node
     */
    'requested_to_leave': boolean;
    /**
     * indicates whether the node has been forced to leave by the network, typically via ban
     * @type {boolean}
     * @memberof Node
     */
    'forced_to_leave': boolean;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'leave_height': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'ip_address': string;
    /**
     * the currently set version of the node
     * @type {string}
     * @memberof Node
     */
    'version': string;
    /**
     * the accumlated slash points, reset at churn but excessive slash points may carry over
     * @type {number}
     * @memberof Node
     */
    'slash_points': number;
    /**
     * 
     * @type {NodeJail}
     * @memberof Node
     */
    'jail': NodeJail;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'current_award': string;
    /**
     * the last observed heights for all chain by the node
     * @type {Array<ChainHeight>}
     * @memberof Node
     */
    'observe_chains': Array<ChainHeight>;
    /**
     * 
     * @type {NodePreflightStatus}
     * @memberof Node
     */
    'preflight_status': NodePreflightStatus;
    /**
     * 
     * @type {NodeBondProviders}
     * @memberof Node
     */
    'bond_providers': NodeBondProviders;
}

export const NodeStatusEnum = {
    Active: 'Active',
    Whitelisted: 'Whitelisted',
    Standby: 'Standby',
    Disabled: 'Disabled'
} as const;

export type NodeStatusEnum = typeof NodeStatusEnum[keyof typeof NodeStatusEnum];

/**
 * 
 * @export
 * @interface NodeBondProvider
 */
export interface NodeBondProvider {
    /**
     * 
     * @type {string}
     * @memberof NodeBondProvider
     */
    'bond_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBondProvider
     */
    'bond'?: string;
}
/**
 * 
 * @export
 * @interface NodeBondProviders
 */
export interface NodeBondProviders {
    /**
     * 
     * @type {string}
     * @memberof NodeBondProviders
     */
    'node_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBondProviders
     */
    'node_operator_fee'?: string;
    /**
     * 
     * @type {NodeBondProvider}
     * @memberof NodeBondProviders
     */
    'providers'?: NodeBondProvider;
}
/**
 * 
 * @export
 * @interface NodeJail
 */
export interface NodeJail {
    /**
     * 
     * @type {string}
     * @memberof NodeJail
     */
    'node_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof NodeJail
     */
    'release_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeJail
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface NodePreflightStatus
 */
export interface NodePreflightStatus {
    /**
     * the next status of the node
     * @type {string}
     * @memberof NodePreflightStatus
     */
    'status': string;
    /**
     * the reason for the transition to the next status
     * @type {string}
     * @memberof NodePreflightStatus
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof NodePreflightStatus
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface NodePubKeySet
 */
export interface NodePubKeySet {
    /**
     * 
     * @type {string}
     * @memberof NodePubKeySet
     */
    'secp256k1'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodePubKeySet
     */
    'ed25519'?: string;
}
/**
 * 
 * @export
 * @interface ObservedTx
 */
export interface ObservedTx {
    /**
     * 
     * @type {Tx}
     * @memberof ObservedTx
     */
    'tx': Tx;
    /**
     * 
     * @type {string}
     * @memberof ObservedTx
     */
    'status'?: ObservedTxStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservedTx
     */
    'out_hashes'?: Array<string>;
    /**
     * the block height of the observed transaction on the source chain, not provided if chain is THOR
     * @type {number}
     * @memberof ObservedTx
     */
    'block_height'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservedTx
     */
    'signers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ObservedTx
     */
    'observed_pub_key'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObservedTx
     */
    'keysign_ms'?: number;
    /**
     * the finalised height of the observed transaction on the source chain, not provided if chain is THOR
     * @type {number}
     * @memberof ObservedTx
     */
    'finalise_height'?: number;
    /**
     * the outbound aggregator to use, will also match a suffix
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator'?: string;
    /**
     * the aggregator target asset provided to transferOutAndCall
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator_target'?: string;
    /**
     * the aggregator target asset limit provided to transferOutAndCall
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator_target_limit'?: string;
}

export const ObservedTxStatusEnum = {
    Done: 'done',
    Incomplete: 'incomplete'
} as const;

export type ObservedTxStatusEnum = typeof ObservedTxStatusEnum[keyof typeof ObservedTxStatusEnum];

/**
 * 
 * @export
 * @interface POLResponse
 */
export interface POLResponse {
    /**
     * total amount of RUNE deposited into the pools
     * @type {string}
     * @memberof POLResponse
     */
    'rune_deposited': string;
    /**
     * total amount of RUNE withdrawn from the pools
     * @type {string}
     * @memberof POLResponse
     */
    'rune_withdrawn': string;
    /**
     * total value of protocol\'s LP position in RUNE value
     * @type {string}
     * @memberof POLResponse
     */
    'value': string;
    /**
     * profit and loss of protocol owned liquidity
     * @type {string}
     * @memberof POLResponse
     */
    'pnl': string;
    /**
     * current amount of rune deposited
     * @type {string}
     * @memberof POLResponse
     */
    'current_deposit': string;
}
/**
 * 
 * @export
 * @interface Ping
 */
export interface Ping {
    /**
     * 
     * @type {string}
     * @memberof Ping
     */
    'ping'?: string;
}
/**
 * 
 * @export
 * @interface Pool
 */
export interface Pool {
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'balance_rune': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'balance_asset': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'asset': string;
    /**
     * the total pool liquidity provider units
     * @type {string}
     * @memberof Pool
     */
    'LP_units': string;
    /**
     * the total pool units, this is the sum of LP and synth units
     * @type {string}
     * @memberof Pool
     */
    'pool_units': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'decimals'?: number;
    /**
     * the total synth units in the pool
     * @type {string}
     * @memberof Pool
     */
    'synth_units': string;
    /**
     * the total supply of synths for the asset
     * @type {string}
     * @memberof Pool
     */
    'synth_supply': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'pending_inbound_rune': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'pending_inbound_asset': string;
}
/**
 * 
 * @export
 * @interface QueueResponse
 */
export interface QueueResponse {
    /**
     * 
     * @type {number}
     * @memberof QueueResponse
     */
    'swap': number;
    /**
     * number of signed outbound tx in the queue
     * @type {number}
     * @memberof QueueResponse
     */
    'outbound': number;
    /**
     * 
     * @type {number}
     * @memberof QueueResponse
     */
    'internal': number;
    /**
     * scheduled outbound value in RUNE
     * @type {string}
     * @memberof QueueResponse
     */
    'scheduled_outbound_value': string;
}
/**
 * 
 * @export
 * @interface TssKeysignMetric
 */
export interface TssKeysignMetric {
    /**
     * 
     * @type {string}
     * @memberof TssKeysignMetric
     */
    'tx_id'?: string;
    /**
     * 
     * @type {Array<TssMetric>}
     * @memberof TssKeysignMetric
     */
    'node_tss_times': Array<TssMetric>;
}
/**
 * 
 * @export
 * @interface TssMetric
 */
export interface TssMetric {
    /**
     * 
     * @type {string}
     * @memberof TssMetric
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof TssMetric
     */
    'tss_time'?: number;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'from_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'to_address'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    'gas': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface TxOutItem
 */
export interface TxOutItem {
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'chain': string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'to_address': string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'vault_pub_key'?: string;
    /**
     * 
     * @type {Coin}
     * @memberof TxOutItem
     */
    'coin': Coin;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'memo'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof TxOutItem
     */
    'max_gas': Array<Coin>;
    /**
     * 
     * @type {number}
     * @memberof TxOutItem
     */
    'gas_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'in_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'out_hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxOutItem
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface TxResponse
 */
export interface TxResponse {
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxResponse
     */
    'observed_tx'?: ObservedTx;
    /**
     * 
     * @type {TssKeysignMetric}
     * @memberof TxResponse
     */
    'keysign_metric'?: TssKeysignMetric;
}
/**
 * 
 * @export
 * @interface TxSignersResponse
 */
export interface TxSignersResponse {
    /**
     * 
     * @type {string}
     * @memberof TxSignersResponse
     */
    'tx_id'?: string;
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxSignersResponse
     */
    'tx': ObservedTx;
    /**
     * 
     * @type {number}
     * @memberof TxSignersResponse
     */
    'height'?: number;
    /**
     * 
     * @type {Array<ObservedTx>}
     * @memberof TxSignersResponse
     */
    'txs': Array<ObservedTx>;
    /**
     * 
     * @type {Array<ObservedTx>}
     * @memberof TxSignersResponse
     */
    'actions': Array<ObservedTx>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TxSignersResponse
     */
    'out_txs': Array<string>;
    /**
     * the thorchain height at which the outbound was finalised
     * @type {number}
     * @memberof TxSignersResponse
     */
    'finalised_height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TxSignersResponse
     */
    'updated_vault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TxSignersResponse
     */
    'reverted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TxSignersResponse
     */
    'outbound_height'?: number;
}
/**
 * 
 * @export
 * @interface Vault
 */
export interface Vault {
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'block_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Vault
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'type'?: VaultTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'status_since'?: number;
    /**
     * the list of node public keys which are members of the vault
     * @type {Array<string>}
     * @memberof Vault
     */
    'membership'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vault
     */
    'chains'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'inbound_tx_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'outbound_tx_count'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Vault
     */
    'pending_tx_block_heights'?: Array<number>;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof Vault
     */
    'routers': Array<VaultRouter>;
    /**
     * 
     * @type {Array<VaultAddress>}
     * @memberof Vault
     */
    'addresses': Array<VaultAddress>;
}

export const VaultTypeEnum = {
    AsgardVault: 'AsgardVault',
    YggdrasilVault: 'YggdrasilVault'
} as const;

export type VaultTypeEnum = typeof VaultTypeEnum[keyof typeof VaultTypeEnum];

/**
 * 
 * @export
 * @interface VaultAddress
 */
export interface VaultAddress {
    /**
     * 
     * @type {string}
     * @memberof VaultAddress
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAddress
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface VaultInfo
 */
export interface VaultInfo {
    /**
     * 
     * @type {string}
     * @memberof VaultInfo
     */
    'pub_key': string;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof VaultInfo
     */
    'routers': Array<VaultRouter>;
}
/**
 * 
 * @export
 * @interface VaultPubkeysResponse
 */
export interface VaultPubkeysResponse {
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'asgard': Array<VaultInfo>;
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'yggdrasil': Array<VaultInfo>;
}
/**
 * 
 * @export
 * @interface VaultRouter
 */
export interface VaultRouter {
    /**
     * 
     * @type {string}
     * @memberof VaultRouter
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultRouter
     */
    'router'?: string;
}
/**
 * 
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
    /**
     * current version
     * @type {string}
     * @memberof VersionResponse
     */
    'current': string;
    /**
     * next version
     * @type {string}
     * @memberof VersionResponse
     */
    'next': string;
    /**
     * querier version
     * @type {string}
     * @memberof VersionResponse
     */
    'querier': string;
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<Ping> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiquidityProvidersApi - axios parameter creator
 * @export
 */
export const LiquidityProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider: async (asset: string, address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProvider', 'asset', asset)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('liquidityProvider', 'address', address)
            const localVarPath = `/thorchain/pool/{asset}/liquidity_provider/{address}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProviders', 'asset', asset)
            const localVarPath = `/thorchain/pool/{asset}/liquidity_providers`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiquidityProvidersApi - functional programming interface
 * @export
 */
export const LiquidityProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiquidityProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProvider(asset: string, address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiquidityProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProvider(asset, address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProviders(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiquidityProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviders(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LiquidityProvidersApi - factory interface
 * @export
 */
export const LiquidityProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiquidityProvidersApiFp(configuration)
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider(asset: string, address: string, height?: number, options?: any): AxiosPromise<Array<LiquidityProvider>> {
            return localVarFp.liquidityProvider(asset, address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders(asset: string, height?: number, options?: any): AxiosPromise<Array<LiquidityProvider>> {
            return localVarFp.liquidityProviders(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiquidityProvidersApi - object-oriented interface
 * @export
 * @class LiquidityProvidersApi
 * @extends {BaseAPI}
 */
export class LiquidityProvidersApi extends BaseAPI {
    /**
     * Returns the liquidity provider information for an address and asset.
     * @param {string} asset 
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    public liquidityProvider(asset: string, address: string, height?: number, options?: AxiosRequestConfig) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProvider(asset, address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all liquidity provider information for an asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    public liquidityProviders(asset: string, height?: number, options?: AxiosRequestConfig) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProviders(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MimirApi - axios parameter creator
 * @export
 */
export const MimirApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/mimir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/mimir/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey: async (key: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('mimirKey', 'key', key)
            const localVarPath = `/thorchain/mimir/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('mimirNode', 'address', address)
            const localVarPath = `/thorchain/mimir/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/mimir/nodes_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MimirApi - functional programming interface
 * @export
 */
export const MimirApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MimirApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimir(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimir(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirAdmin(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirAdmin(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirKey(key: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirKey(key, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirNode(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirNode(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirNodes(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirNodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirNodes(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MimirApi - factory interface
 * @export
 */
export const MimirApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MimirApiFp(configuration)
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir(height?: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.mimir(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin(height?: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.mimirAdmin(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey(key: string, height?: number, options?: any): AxiosPromise<number> {
            return localVarFp.mimirKey(key, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode(address: string, height?: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.mimirNode(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes(height?: number, options?: any): AxiosPromise<MimirNodesResponse> {
            return localVarFp.mimirNodes(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MimirApi - object-oriented interface
 * @export
 * @class MimirApi
 * @extends {BaseAPI}
 */
export class MimirApi extends BaseAPI {
    /**
     * Returns current active mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimir(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimir(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current admin mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirAdmin(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirAdmin(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current active mimir configuration for the provided key.
     * @param {string} key the mimir key to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirKey(key: string, height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirKey(key, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current node mimir configuration for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirNode(address: string, height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirNode(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current node mimir votes.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirNodes(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirNodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('ban', 'address', address)
            const localVarPath = `/thorchain/ban/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain: async (chain: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('lastblockChain', 'chain', chain)
            const localVarPath = `/thorchain/lastblock/{chain}`
                .replace(`{${"chain"}}`, encodeURIComponent(String(chain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/ragnarok`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ban(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ban(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constants(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.constants(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboundAddresses(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboundAddresses(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastblock(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LastBlock>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastblock(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastblockChain(chain: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LastBlock>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastblockChain(chain, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async network(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.network(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragnarok(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragnarok(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async version(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.version(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban(address: string, height?: number, options?: any): AxiosPromise<BanResponse> {
            return localVarFp.ban(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants(height?: number, options?: any): AxiosPromise<ConstantsResponse> {
            return localVarFp.constants(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses(height?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.inboundAddresses(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock(height?: number, options?: any): AxiosPromise<Array<LastBlock>> {
            return localVarFp.lastblock(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain(chain: string, height?: number, options?: any): AxiosPromise<Array<LastBlock>> {
            return localVarFp.lastblockChain(chain, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network(height?: number, options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.network(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok(height?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.ragnarok(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(height?: number, options?: any): AxiosPromise<VersionResponse> {
            return localVarFp.version(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * Returns the ban status for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public ban(address: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).ban(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns constant configuration, can be overridden by mimir.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public constants(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).constants(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the set of asgard addresses that should be used for inbound transactions.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public inboundAddresses(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).inboundAddresses(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for all chains.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public lastblock(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).lastblock(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for the provided chain.
     * @param {string} chain 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public lastblockChain(chain: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).lastblockChain(chain, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns network overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public network(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).network(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a boolean indicating whether the chain is in ragnarok.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public ragnarok(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).ragnarok(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public version(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).version(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('node', 'address', address)
            const localVarPath = `/thorchain/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async node(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.node(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodes(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Node>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodes(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node(address: string, height?: number, options?: any): AxiosPromise<Node> {
            return localVarFp.node(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes(height?: number, options?: any): AxiosPromise<Array<Node>> {
            return localVarFp.nodes(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * Returns node information for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public node(address: string, height?: number, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).node(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns node information for all registered validators.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public nodes(height?: number, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).nodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * POLApi - axios parameter creator
 * @export
 */
export const POLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/pol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * POLApi - functional programming interface
 * @export
 */
export const POLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = POLApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pol(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<POLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pol(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * POLApi - factory interface
 * @export
 */
export const POLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = POLApiFp(configuration)
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol(height?: number, options?: any): AxiosPromise<POLResponse> {
            return localVarFp.pol(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * POLApi - object-oriented interface
 * @export
 * @class POLApi
 * @extends {BaseAPI}
 */
export class POLApi extends BaseAPI {
    /**
     * Returns protocol owned liquidity overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POLApi
     */
    public pol(height?: number, options?: AxiosRequestConfig) {
        return POLApiFp(this.configuration).pol(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pool', 'asset', asset)
            const localVarPath = `/thorchain/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pool(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pools(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pools(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(asset: string, height?: number, options?: any): AxiosPromise<Pool> {
            return localVarFp.pool(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools(height?: number, options?: any): AxiosPromise<Array<Pool>> {
            return localVarFp.pools(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * Returns the pool information for the provided asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public pool(asset: string, height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).pool(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the pool information for all assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public pools(height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).pools(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueueApi - axios parameter creator
 * @export
 */
export const QueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue/outbound`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue/scheduled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueueApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queue(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queue(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueOutbound(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TxOutItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueOutbound(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueScheduled(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TxOutItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueScheduled(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueueApiFp(configuration)
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue(height?: number, options?: any): AxiosPromise<QueueResponse> {
            return localVarFp.queue(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound(height?: number, options?: any): AxiosPromise<Array<TxOutItem>> {
            return localVarFp.queueOutbound(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled(height?: number, options?: any): AxiosPromise<Array<TxOutItem>> {
            return localVarFp.queueScheduled(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI {
    /**
     * Returns queue statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queue(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queue(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the outbound queue including estimated RUNE values.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueOutbound(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueOutbound(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the scheduled queue.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueScheduled(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueScheduled(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TSSApi - axios parameter creator
 * @export
 */
export const TSSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysign', 'height', height)
            const localVarPath = `/thorchain/keysign/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey: async (height: number, pubkey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysignPubkey', 'height', height)
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('keysignPubkey', 'pubkey', pubkey)
            const localVarPath = `/thorchain/keysign/{height}/{pubkey}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen: async (pubkey: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('metricsKeygen', 'pubkey', pubkey)
            const localVarPath = `/thorchain/metric/keygen/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TSSApi - functional programming interface
 * @export
 */
export const TSSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TSSApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysign(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysign(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysignPubkey(height: number, pubkey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysignPubkey(height, pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsKeygen(pubkey: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsKeygen(pubkey, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TSSApi - factory interface
 * @export
 */
export const TSSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TSSApiFp(configuration)
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign(height: number, options?: any): AxiosPromise<KeysignResponse> {
            return localVarFp.keysign(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey(height: number, pubkey: string, options?: any): AxiosPromise<void> {
            return localVarFp.keysignPubkey(height, pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(height?: number, options?: any): AxiosPromise<MetricsResponse> {
            return localVarFp.metrics(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen(pubkey: string, height?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.metricsKeygen(pubkey, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TSSApi - object-oriented interface
 * @export
 * @class TSSApi
 * @extends {BaseAPI}
 */
export class TSSApi extends BaseAPI {
    /**
     * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
     * @param {number} height 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keysign(height: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keysign(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
     * @param {number} height 
     * @param {string} pubkey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keysignPubkey(height: number, pubkey: string, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keysignPubkey(height, pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keygen and keysign metrics for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public metrics(height?: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).metrics(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keygen metrics for the provided vault pubkey.
     * @param {string} pubkey 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public metricsKeygen(pubkey: string, height?: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).metricsKeygen(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThornamesApi - axios parameter creator
 * @export
 */
export const ThornamesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname: async (name: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('thorname', 'name', name)
            const localVarPath = `/thorchain/thorname/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThornamesApi - functional programming interface
 * @export
 */
export const ThornamesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThornamesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thorname(name: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thorname(name, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThornamesApi - factory interface
 * @export
 */
export const ThornamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThornamesApiFp(configuration)
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname(name: string, height?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.thorname(name, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThornamesApi - object-oriented interface
 * @export
 * @class ThornamesApi
 * @extends {BaseAPI}
 */
export class ThornamesApi extends BaseAPI {
    /**
     * Returns addresses registered to the provided thorname.
     * @param {string} name the thornode to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThornamesApi
     */
    public thorname(name: string, height?: number, options?: AxiosRequestConfig) {
        return ThornamesApiFp(this.configuration).thorname(name, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('tx', 'hash', hash)
            const localVarPath = `/thorchain/tx/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txSigners', 'hash', hash)
            const localVarPath = `/thorchain/tx/{hash}/signers`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tx(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tx(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txSigners(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxSignersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txSigners(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx(hash: string, height?: number, options?: any): AxiosPromise<TxResponse> {
            return localVarFp.tx(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners(hash: string, height?: number, options?: any): AxiosPromise<TxSignersResponse> {
            return localVarFp.txSigners(hash, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Returns the observed transaction for a provided inbound or outbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public tx(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).tx(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the signers for a provided inbound or outbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txSigners(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).txSigners(hash, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VaultsApi - axios parameter creator
 * @export
 */
export const VaultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/vaults/asgard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault: async (pubkey: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('vault', 'pubkey', pubkey)
            const localVarPath = `/thorchain/vaults/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/vaults/pubkeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/vaults/yggdrasil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VaultsApi - functional programming interface
 * @export
 */
export const VaultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VaultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asgard(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vault>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asgard(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vault(pubkey: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vault(pubkey, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vaultPubkeys(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultPubkeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vaultPubkeys(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async yggdrasil(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vault>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.yggdrasil(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VaultsApi - factory interface
 * @export
 */
export const VaultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VaultsApiFp(configuration)
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard(height?: number, options?: any): AxiosPromise<Array<Vault>> {
            return localVarFp.asgard(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault(pubkey: string, height?: number, options?: any): AxiosPromise<Vault> {
            return localVarFp.vault(pubkey, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys(height?: number, options?: any): AxiosPromise<VaultPubkeysResponse> {
            return localVarFp.vaultPubkeys(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil(height?: number, options?: any): AxiosPromise<Array<Vault>> {
            return localVarFp.yggdrasil(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
export class VaultsApi extends BaseAPI {
    /**
     * Returns current asgard vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public asgard(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).asgard(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the vault for the provided pubkey.
     * @param {string} pubkey 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public vault(pubkey: string, height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).vault(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all pubkeys for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public vaultPubkeys(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).vaultPubkeys(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current yggdrasil vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public yggdrasil(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).yggdrasil(height, options).then((request) => request(this.axios, this.basePath));
    }
}


