/* tslint:disable */
/* eslint-disable */
/**
 * Thornode API
 * Thornode REST API.
 *
 * The version of the OpenAPI document: 1.134.0
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BanResponse
 */
export interface BanResponse {
    /**
     * 
     * @type {string}
     * @memberof BanResponse
     */
    'node_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof BanResponse
     */
    'block_height'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BanResponse
     */
    'signers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BaseQuoteResponse
 */
export interface BaseQuoteResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'inbound_address'?: string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof BaseQuoteResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof BaseQuoteResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of thorchain blocks the outbound will be delayed
     * @type {number}
     * @memberof BaseQuoteResponse
     */
    'outbound_delay_blocks'?: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof BaseQuoteResponse
     */
    'outbound_delay_seconds'?: number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof BaseQuoteResponse
     */
    'fees'?: QuoteFees;
    /**
     * the EVM chain router contract address
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'router'?: string;
    /**
     * expiration timestamp in unix seconds
     * @type {number}
     * @memberof BaseQuoteResponse
     */
    'expiry'?: number;
    /**
     * static warning message
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'warning'?: string;
    /**
     * chain specific quote notes
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'notes'?: string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'dust_threshold'?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'recommended_min_amount_in'?: string;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'recommended_gas_rate'?: string;
    /**
     * the units of the recommended gas rate
     * @type {string}
     * @memberof BaseQuoteResponse
     */
    'gas_rate_units'?: string;
}
/**
 * 
 * @export
 * @interface BlockResponse
 */
export interface BlockResponse {
    /**
     * 
     * @type {BlockResponseId}
     * @memberof BlockResponse
     */
    'id': BlockResponseId;
    /**
     * 
     * @type {BlockResponseHeader}
     * @memberof BlockResponse
     */
    'header': BlockResponseHeader;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BlockResponse
     */
    'begin_block_events': Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BlockResponse
     */
    'end_block_events': Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {Array<BlockTx>}
     * @memberof BlockResponse
     */
    'txs': Array<BlockTx> | null;
}
/**
 * 
 * @export
 * @interface BlockResponseHeader
 */
export interface BlockResponseHeader {
    /**
     * 
     * @type {BlockResponseHeaderVersion}
     * @memberof BlockResponseHeader
     */
    'version': BlockResponseHeaderVersion;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'chain_id': string;
    /**
     * 
     * @type {number}
     * @memberof BlockResponseHeader
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'time': string;
    /**
     * 
     * @type {BlockResponseId}
     * @memberof BlockResponseHeader
     */
    'last_block_id': BlockResponseId;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'last_commit_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'data_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'validators_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'next_validators_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'consensus_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'app_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'last_results_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'evidence_hash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeader
     */
    'proposer_address': string;
}
/**
 * 
 * @export
 * @interface BlockResponseHeaderVersion
 */
export interface BlockResponseHeaderVersion {
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeaderVersion
     */
    'block': string;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseHeaderVersion
     */
    'app': string;
}
/**
 * 
 * @export
 * @interface BlockResponseId
 */
export interface BlockResponseId {
    /**
     * 
     * @type {string}
     * @memberof BlockResponseId
     */
    'hash': string;
    /**
     * 
     * @type {BlockResponseIdParts}
     * @memberof BlockResponseId
     */
    'parts': BlockResponseIdParts;
}
/**
 * 
 * @export
 * @interface BlockResponseIdParts
 */
export interface BlockResponseIdParts {
    /**
     * 
     * @type {number}
     * @memberof BlockResponseIdParts
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof BlockResponseIdParts
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface BlockTx
 */
export interface BlockTx {
    /**
     * 
     * @type {string}
     * @memberof BlockTx
     */
    'hash': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BlockTx
     */
    'tx': { [key: string]: any; };
    /**
     * 
     * @type {BlockTxResult}
     * @memberof BlockTx
     */
    'result': BlockTxResult;
}
/**
 * 
 * @export
 * @interface BlockTxResult
 */
export interface BlockTxResult {
    /**
     * 
     * @type {number}
     * @memberof BlockTxResult
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof BlockTxResult
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockTxResult
     */
    'log'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockTxResult
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockTxResult
     */
    'gas_wanted'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockTxResult
     */
    'gas_used'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BlockTxResult
     */
    'events'?: Array<{ [key: string]: string; }> | null;
    /**
     * 
     * @type {string}
     * @memberof BlockTxResult
     */
    'codespace'?: string;
}
/**
 * 
 * @export
 * @interface Borrower
 */
export interface Borrower {
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'debt_issued': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'debt_repaid': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'debt_current': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'collateral_deposited': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'collateral_withdrawn': string;
    /**
     * 
     * @type {string}
     * @memberof Borrower
     */
    'collateral_current': string;
    /**
     * 
     * @type {number}
     * @memberof Borrower
     */
    'last_open_height': number;
    /**
     * 
     * @type {number}
     * @memberof Borrower
     */
    'last_repay_height': number;
}
/**
 * 
 * @export
 * @interface BorrowersResponse
 */
export interface BorrowersResponse extends Array<Borrower> {
}
/**
 * 
 * @export
 * @interface ChainHeight
 */
export interface ChainHeight {
    /**
     * 
     * @type {string}
     * @memberof ChainHeight
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof ChainHeight
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    'amount': string;
    /**
     * 
     * @type {number}
     * @memberof Coin
     */
    'decimals'?: number;
}
/**
 * 
 * @export
 * @interface ConstantsResponse
 */
export interface ConstantsResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'int_64_values'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'bool_values'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'string_values'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface DerivedPool
 */
export interface DerivedPool {
    /**
     * 
     * @type {string}
     * @memberof DerivedPool
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof DerivedPool
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof DerivedPool
     */
    'decimals'?: number;
    /**
     * 
     * @type {string}
     * @memberof DerivedPool
     */
    'balance_asset': string;
    /**
     * 
     * @type {string}
     * @memberof DerivedPool
     */
    'balance_rune': string;
    /**
     * the depth of the derived virtual pool relative to L1 pool (in basis points)
     * @type {string}
     * @memberof DerivedPool
     */
    'derived_depth_bps': string;
}
/**
 * 
 * @export
 * @interface DerivedPoolsResponse
 */
export interface DerivedPoolsResponse extends Array<DerivedPool> {
}
/**
 * 
 * @export
 * @interface InboundAddress
 */
export interface InboundAddress {
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'pub_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'router'?: string;
    /**
     * Returns true if trading is unavailable for this chain, either because trading is halted globally or specifically for this chain
     * @type {boolean}
     * @memberof InboundAddress
     */
    'halted': boolean;
    /**
     * Returns true if trading is paused globally
     * @type {boolean}
     * @memberof InboundAddress
     */
    'global_trading_paused'?: boolean;
    /**
     * Returns true if trading is paused for this chain
     * @type {boolean}
     * @memberof InboundAddress
     */
    'chain_trading_paused'?: boolean;
    /**
     * Returns true if LP actions are paused for this chain
     * @type {boolean}
     * @memberof InboundAddress
     */
    'chain_lp_actions_paused'?: boolean;
    /**
     * The minimum fee rate used by vaults to send outbound TXs. The actual fee rate may be higher. For EVM chains this is returned in gwei (1e9).
     * @type {string}
     * @memberof InboundAddress
     */
    'gas_rate'?: string;
    /**
     * Units of the gas_rate.
     * @type {string}
     * @memberof InboundAddress
     */
    'gas_rate_units'?: string;
    /**
     * Avg size of outbound TXs on each chain. For UTXO chains it may be larger than average, as it takes into account vault consolidation txs, which can have many vouts
     * @type {string}
     * @memberof InboundAddress
     */
    'outbound_tx_size'?: string;
    /**
     * The total outbound fee charged to the user for outbound txs in the gas asset of the chain.
     * @type {string}
     * @memberof InboundAddress
     */
    'outbound_fee'?: string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof InboundAddress
     */
    'dust_threshold'?: string;
}
/**
 * 
 * @export
 * @interface InboundAddressesResponse
 */
export interface InboundAddressesResponse extends Array<InboundAddress> {
}
/**
 * 
 * @export
 * @interface InboundConfirmationCountedStage
 */
export interface InboundConfirmationCountedStage {
    /**
     * the THORChain block height when confirmation counting began
     * @type {number}
     * @memberof InboundConfirmationCountedStage
     */
    'counting_start_height'?: number;
    /**
     * the external source chain for which confirmation counting takes place
     * @type {string}
     * @memberof InboundConfirmationCountedStage
     */
    'chain'?: string;
    /**
     * the block height on the external source chain when the transaction was observed
     * @type {number}
     * @memberof InboundConfirmationCountedStage
     */
    'external_observed_height'?: number;
    /**
     * the block height on the external source chain when confirmation counting will be complete
     * @type {number}
     * @memberof InboundConfirmationCountedStage
     */
    'external_confirmation_delay_height'?: number;
    /**
     * the estimated remaining seconds before confirmation counting completes
     * @type {number}
     * @memberof InboundConfirmationCountedStage
     */
    'remaining_confirmation_seconds'?: number;
    /**
     * returns true if no transaction confirmation counting remains to be done
     * @type {boolean}
     * @memberof InboundConfirmationCountedStage
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface InboundFinalisedStage
 */
export interface InboundFinalisedStage {
    /**
     * returns true if the inbound transaction has been finalised (THORChain agreeing it exists)
     * @type {boolean}
     * @memberof InboundFinalisedStage
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface InboundObservedStage
 */
export interface InboundObservedStage {
    /**
     * returns true if any nodes have observed the transaction (to be deprecated in favour of counts)
     * @type {boolean}
     * @memberof InboundObservedStage
     */
    'started'?: boolean;
    /**
     * number of signers for pre-confirmation-counting observations
     * @type {number}
     * @memberof InboundObservedStage
     */
    'pre_confirmation_count'?: number;
    /**
     * number of signers for final observations, after any confirmation counting complete
     * @type {number}
     * @memberof InboundObservedStage
     */
    'final_count': number;
    /**
     * returns true if no transaction observation remains to be done
     * @type {boolean}
     * @memberof InboundObservedStage
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface InvariantResponse
 */
export interface InvariantResponse {
    /**
     * The name of the invariant.
     * @type {string}
     * @memberof InvariantResponse
     */
    'invariant': string;
    /**
     * Returns true if the invariant is broken.
     * @type {boolean}
     * @memberof InvariantResponse
     */
    'broken': boolean;
    /**
     * Informative message about the invariant result.
     * @type {Array<string>}
     * @memberof InvariantResponse
     */
    'msg': Array<string>;
}
/**
 * 
 * @export
 * @interface InvariantsResponse
 */
export interface InvariantsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof InvariantsResponse
     */
    'invariants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Keygen
 */
export interface Keygen {
    /**
     * 
     * @type {string}
     * @memberof Keygen
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Keygen
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Keygen
     */
    'members'?: Array<string>;
}
/**
 * 
 * @export
 * @interface KeygenBlock
 */
export interface KeygenBlock {
    /**
     * the height of the keygen block
     * @type {number}
     * @memberof KeygenBlock
     */
    'height'?: number;
    /**
     * 
     * @type {Array<Keygen>}
     * @memberof KeygenBlock
     */
    'keygens': Array<Keygen>;
}
/**
 * 
 * @export
 * @interface KeygenMetric
 */
export interface KeygenMetric {
    /**
     * 
     * @type {string}
     * @memberof KeygenMetric
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<NodeKeygenMetric>}
     * @memberof KeygenMetric
     */
    'node_tss_times': Array<NodeKeygenMetric>;
}
/**
 * 
 * @export
 * @interface KeygenMetricsResponse
 */
export interface KeygenMetricsResponse extends Array<KeygenMetric> {
}
/**
 * 
 * @export
 * @interface KeygenResponse
 */
export interface KeygenResponse {
    /**
     * 
     * @type {KeygenBlock}
     * @memberof KeygenResponse
     */
    'keygen_block': KeygenBlock;
    /**
     * 
     * @type {string}
     * @memberof KeygenResponse
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface KeysignInfo
 */
export interface KeysignInfo {
    /**
     * the block(s) in which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue
     * @type {number}
     * @memberof KeysignInfo
     */
    'height'?: number;
    /**
     * 
     * @type {Array<TxOutItem>}
     * @memberof KeysignInfo
     */
    'tx_array': Array<TxOutItem>;
}
/**
 * 
 * @export
 * @interface KeysignMetrics
 */
export interface KeysignMetrics {
    /**
     * 
     * @type {string}
     * @memberof KeysignMetrics
     */
    'tx_id'?: string;
    /**
     * 
     * @type {Array<TssMetric>}
     * @memberof KeysignMetrics
     */
    'node_tss_times'?: Array<TssMetric>;
}
/**
 * 
 * @export
 * @interface KeysignResponse
 */
export interface KeysignResponse {
    /**
     * 
     * @type {KeysignInfo}
     * @memberof KeysignResponse
     */
    'keysign': KeysignInfo;
    /**
     * 
     * @type {string}
     * @memberof KeysignResponse
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface LastBlock
 */
export interface LastBlock {
    /**
     * 
     * @type {string}
     * @memberof LastBlock
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'last_observed_in': number;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'last_signed_out': number;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'thorchain': number;
}
/**
 * 
 * @export
 * @interface LastBlockResponse
 */
export interface LastBlockResponse extends Array<LastBlock> {
}
/**
 * 
 * @export
 * @interface LiquidityProvider
 */
export interface LiquidityProvider {
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'rune_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_add_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_withdraw_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'units': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_rune': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'rune_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'rune_redeem_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_redeem_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'luvi_deposit_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'luvi_redeem_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'luvi_growth_pct'?: string;
}
/**
 * 
 * @export
 * @interface LiquidityProviderSummary
 */
export interface LiquidityProviderSummary {
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'rune_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'asset_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProviderSummary
     */
    'last_add_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProviderSummary
     */
    'last_withdraw_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'units': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'pending_rune': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'pending_asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'pending_tx_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'rune_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProviderSummary
     */
    'asset_deposit_value': string;
}
/**
 * 
 * @export
 * @interface LiquidityProvidersResponse
 */
export interface LiquidityProvidersResponse extends Array<LiquidityProviderSummary> {
}
/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * 
     * @type {KeygenMetricsResponse}
     * @memberof MetricsResponse
     */
    'keygen'?: KeygenMetricsResponse;
    /**
     * 
     * @type {KeysignMetrics}
     * @memberof MetricsResponse
     */
    'keysign'?: KeysignMetrics;
}
/**
 * 
 * @export
 * @interface MimirNodesResponse
 */
export interface MimirNodesResponse {
    /**
     * 
     * @type {Array<MimirVote>}
     * @memberof MimirNodesResponse
     */
    'mimirs'?: Array<MimirVote>;
}
/**
 * 
 * @export
 * @interface MimirResponse
 */
export interface MimirResponse {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface MimirVote
 */
export interface MimirVote {
    /**
     * 
     * @type {string}
     * @memberof MimirVote
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof MimirVote
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof MimirVote
     */
    'signer'?: string;
}
/**
 * 
 * @export
 * @interface MsgSwap
 */
export interface MsgSwap {
    /**
     * 
     * @type {Tx}
     * @memberof MsgSwap
     */
    'tx': Tx;
    /**
     * the asset to be swapped to
     * @type {string}
     * @memberof MsgSwap
     */
    'target_asset': string;
    /**
     * the destination address to receive the swap output
     * @type {string}
     * @memberof MsgSwap
     */
    'destination'?: string;
    /**
     * the minimum amount of output asset to receive (else cancelling and refunding the swap)
     * @type {string}
     * @memberof MsgSwap
     */
    'trade_target': string;
    /**
     * the affiliate address which will receive any affiliate fee
     * @type {string}
     * @memberof MsgSwap
     */
    'affiliate_address'?: string;
    /**
     * the affiliate fee in basis points
     * @type {string}
     * @memberof MsgSwap
     */
    'affiliate_basis_points': string;
    /**
     * the signer (sender) of the transaction
     * @type {string}
     * @memberof MsgSwap
     */
    'signer'?: string;
    /**
     * the contract address if an aggregator is specified for a non-THORChain SwapOut
     * @type {string}
     * @memberof MsgSwap
     */
    'aggregator'?: string;
    /**
     * the desired output asset of the aggregator SwapOut
     * @type {string}
     * @memberof MsgSwap
     */
    'aggregator_target_address'?: string;
    /**
     * the minimum amount of SwapOut asset to receive (else cancelling the SwapOut and receiving THORChain\'s output)
     * @type {string}
     * @memberof MsgSwap
     */
    'aggregator_target_limit'?: string;
    /**
     * market if immediately completed or refunded, limit if held until fulfillable
     * @type {string}
     * @memberof MsgSwap
     */
    'order_type'?: string;
    /**
     * number of swaps to execute in a streaming swap
     * @type {number}
     * @memberof MsgSwap
     */
    'stream_quantity'?: number;
    /**
     * the interval (in blocks) to execute the streaming swap
     * @type {number}
     * @memberof MsgSwap
     */
    'stream_interval'?: number;
}
/**
 * 
 * @export
 * @interface NetworkResponse
 */
export interface NetworkResponse {
    /**
     * total amount of RUNE awarded to node operators
     * @type {string}
     * @memberof NetworkResponse
     */
    'bond_reward_rune': string;
    /**
     * total of burned BEP2 RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'burned_bep_2_rune': string;
    /**
     * total of burned ERC20 RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'burned_erc_20_rune': string;
    /**
     * total bonded RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_bond_units': string;
    /**
     * effective security bond used to determine maximum pooled RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'effective_security_bond': string;
    /**
     * total reserve RUNE
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_reserve': string;
    /**
     * Returns true if there exist RetiringVaults which have not finished migrating funds to new ActiveVaults
     * @type {boolean}
     * @memberof NetworkResponse
     */
    'vaults_migrating': boolean;
    /**
     * Sum of the gas the network has spent to send outbounds
     * @type {string}
     * @memberof NetworkResponse
     */
    'gas_spent_rune': string;
    /**
     * Sum of the gas withheld from users to cover outbound gas
     * @type {string}
     * @memberof NetworkResponse
     */
    'gas_withheld_rune': string;
    /**
     * Current outbound fee multiplier, in basis points
     * @type {string}
     * @memberof NetworkResponse
     */
    'outbound_fee_multiplier'?: string;
    /**
     * the outbound transaction fee in rune, converted from the NativeOutboundFeeUSD mimir (after USD fees are enabled)
     * @type {string}
     * @memberof NetworkResponse
     */
    'native_outbound_fee_rune': string;
    /**
     * the native transaction fee in rune, converted from the NativeTransactionFeeUSD mimir (after USD fees are enabled)
     * @type {string}
     * @memberof NetworkResponse
     */
    'native_tx_fee_rune': string;
    /**
     * the thorname register fee in rune, converted from the TNSRegisterFeeUSD mimir (after USD fees are enabled)
     * @type {string}
     * @memberof NetworkResponse
     */
    'tns_register_fee_rune': string;
    /**
     * the thorname fee per block in rune, converted from the TNSFeePerBlockUSD mimir (after USD fees are enabled)
     * @type {string}
     * @memberof NetworkResponse
     */
    'tns_fee_per_block_rune': string;
    /**
     * the rune price in tor
     * @type {string}
     * @memberof NetworkResponse
     */
    'rune_price_in_tor': string;
    /**
     * the tor price in rune
     * @type {string}
     * @memberof NetworkResponse
     */
    'tor_price_in_rune': string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'node_address': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'status': NodeStatusEnum;
    /**
     * 
     * @type {NodePubKeySet}
     * @memberof Node
     */
    'pub_key_set': NodePubKeySet;
    /**
     * the consensus pub key for the node
     * @type {string}
     * @memberof Node
     */
    'validator_cons_pub_key': string;
    /**
     * the P2PID (:6040/p2pid endpoint) of the node
     * @type {string}
     * @memberof Node
     */
    'peer_id': string;
    /**
     * the block height at which the node became active
     * @type {number}
     * @memberof Node
     */
    'active_block_height': number;
    /**
     * the block height of the current provided information for the node
     * @type {number}
     * @memberof Node
     */
    'status_since': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'node_operator_address': string;
    /**
     * current node bond
     * @type {string}
     * @memberof Node
     */
    'total_bond': string;
    /**
     * 
     * @type {NodeBondProviders}
     * @memberof Node
     */
    'bond_providers': NodeBondProviders;
    /**
     * the set of vault public keys of which the node is a member
     * @type {Array<string>}
     * @memberof Node
     */
    'signer_membership': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Node
     */
    'requested_to_leave': boolean;
    /**
     * indicates whether the node has been forced to leave by the network, typically via ban
     * @type {boolean}
     * @memberof Node
     */
    'forced_to_leave': boolean;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'leave_height': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'ip_address': string;
    /**
     * the currently set version of the node
     * @type {string}
     * @memberof Node
     */
    'version': string;
    /**
     * the accumulated slash points, reset at churn but excessive slash points may carry over
     * @type {number}
     * @memberof Node
     */
    'slash_points': number;
    /**
     * 
     * @type {NodeJail}
     * @memberof Node
     */
    'jail': NodeJail;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'current_award': string;
    /**
     * the last observed heights for all chain by the node
     * @type {Array<ChainHeight>}
     * @memberof Node
     */
    'observe_chains': Array<ChainHeight>;
    /**
     * 
     * @type {NodePreflightStatus}
     * @memberof Node
     */
    'preflight_status': NodePreflightStatus;
}

export const NodeStatusEnum = {
    Active: 'Active',
    Whitelisted: 'Whitelisted',
    Standby: 'Standby',
    Disabled: 'Disabled'
} as const;

export type NodeStatusEnum = typeof NodeStatusEnum[keyof typeof NodeStatusEnum];

/**
 * 
 * @export
 * @interface NodeBondProvider
 */
export interface NodeBondProvider {
    /**
     * 
     * @type {string}
     * @memberof NodeBondProvider
     */
    'bond_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBondProvider
     */
    'bond'?: string;
}
/**
 * 
 * @export
 * @interface NodeBondProviders
 */
export interface NodeBondProviders {
    /**
     * node operator fee in basis points
     * @type {string}
     * @memberof NodeBondProviders
     */
    'node_operator_fee': string;
    /**
     * all the bond providers for the node
     * @type {Array<NodeBondProvider>}
     * @memberof NodeBondProviders
     */
    'providers': Array<NodeBondProvider>;
}
/**
 * 
 * @export
 * @interface NodeJail
 */
export interface NodeJail {
    /**
     * 
     * @type {number}
     * @memberof NodeJail
     */
    'release_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeJail
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface NodeKeygenMetric
 */
export interface NodeKeygenMetric {
    /**
     * 
     * @type {string}
     * @memberof NodeKeygenMetric
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeKeygenMetric
     */
    'tss_time'?: string;
}
/**
 * 
 * @export
 * @interface NodePreflightStatus
 */
export interface NodePreflightStatus {
    /**
     * the next status of the node
     * @type {string}
     * @memberof NodePreflightStatus
     */
    'status': string;
    /**
     * the reason for the transition to the next status
     * @type {string}
     * @memberof NodePreflightStatus
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof NodePreflightStatus
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface NodePubKeySet
 */
export interface NodePubKeySet {
    /**
     * 
     * @type {string}
     * @memberof NodePubKeySet
     */
    'secp256k1'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodePubKeySet
     */
    'ed25519'?: string;
}
/**
 * 
 * @export
 * @interface NodesResponse
 */
export interface NodesResponse extends Array<Node> {
}
/**
 * 
 * @export
 * @interface ObservedTx
 */
export interface ObservedTx {
    /**
     * 
     * @type {Tx}
     * @memberof ObservedTx
     */
    'tx': Tx;
    /**
     * 
     * @type {string}
     * @memberof ObservedTx
     */
    'observed_pub_key'?: string;
    /**
     * the block height on the external source chain when the transaction was observed, not provided if chain is THOR
     * @type {number}
     * @memberof ObservedTx
     */
    'external_observed_height'?: number;
    /**
     * the block height on the external source chain when confirmation counting will be complete, not provided if chain is THOR
     * @type {number}
     * @memberof ObservedTx
     */
    'external_confirmation_delay_height'?: number;
    /**
     * the outbound aggregator to use, will also match a suffix
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator'?: string;
    /**
     * the aggregator target asset provided to transferOutAndCall
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator_target'?: string;
    /**
     * the aggregator target asset limit provided to transferOutAndCall
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator_target_limit'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservedTx
     */
    'signers'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ObservedTx
     */
    'keysign_ms'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservedTx
     */
    'out_hashes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ObservedTx
     */
    'status'?: ObservedTxStatusEnum;
}

export const ObservedTxStatusEnum = {
    Done: 'done',
    Incomplete: 'incomplete'
} as const;

export type ObservedTxStatusEnum = typeof ObservedTxStatusEnum[keyof typeof ObservedTxStatusEnum];

/**
 * 
 * @export
 * @interface OutboundDelayStage
 */
export interface OutboundDelayStage {
    /**
     * the number of remaining THORChain blocks the outbound will be delayed
     * @type {number}
     * @memberof OutboundDelayStage
     */
    'remaining_delay_blocks'?: number;
    /**
     * the estimated remaining seconds of the outbound delay before it will be sent
     * @type {number}
     * @memberof OutboundDelayStage
     */
    'remaining_delay_seconds'?: number;
    /**
     * returns true if no transaction outbound delay remains
     * @type {boolean}
     * @memberof OutboundDelayStage
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface OutboundFee
 */
export interface OutboundFee {
    /**
     * the asset to display the outbound fee for
     * @type {string}
     * @memberof OutboundFee
     */
    'asset': string;
    /**
     * the asset\'s outbound fee, in (1e8-format) units of the asset
     * @type {string}
     * @memberof OutboundFee
     */
    'outbound_fee': string;
    /**
     * Total RUNE the network has withheld as fees to later cover gas costs for this asset\'s outbounds
     * @type {string}
     * @memberof OutboundFee
     */
    'fee_withheld_rune'?: string;
    /**
     * Total RUNE the network has spent to reimburse gas costs for this asset\'s outbounds
     * @type {string}
     * @memberof OutboundFee
     */
    'fee_spent_rune'?: string;
    /**
     * amount of RUNE by which the fee_withheld_rune exceeds the fee_spent_rune
     * @type {string}
     * @memberof OutboundFee
     */
    'surplus_rune'?: string;
    /**
     * dynamic multiplier basis points, based on the surplus_rune, affecting the size of the outbound_fee
     * @type {string}
     * @memberof OutboundFee
     */
    'dynamic_multiplier_basis_points'?: string;
}
/**
 * 
 * @export
 * @interface OutboundFeesResponse
 */
export interface OutboundFeesResponse extends Array<OutboundFee> {
}
/**
 * 
 * @export
 * @interface OutboundResponse
 */
export interface OutboundResponse extends Array<TxOutItem> {
}
/**
 * 
 * @export
 * @interface OutboundSignedStage
 */
export interface OutboundSignedStage {
    /**
     * THORChain height for which the external outbound is scheduled
     * @type {number}
     * @memberof OutboundSignedStage
     */
    'scheduled_outbound_height'?: number;
    /**
     * THORChain blocks since the scheduled outbound height
     * @type {number}
     * @memberof OutboundSignedStage
     */
    'blocks_since_scheduled'?: number;
    /**
     * returns true if an external transaction has been signed and broadcast (and observed in its mempool)
     * @type {boolean}
     * @memberof OutboundSignedStage
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface POL
 */
export interface POL {
    /**
     * total amount of RUNE deposited into the pools
     * @type {string}
     * @memberof POL
     */
    'rune_deposited': string;
    /**
     * total amount of RUNE withdrawn from the pools
     * @type {string}
     * @memberof POL
     */
    'rune_withdrawn': string;
    /**
     * total value of protocol\'s LP position in RUNE value
     * @type {string}
     * @memberof POL
     */
    'value': string;
    /**
     * profit and loss of protocol owned liquidity
     * @type {string}
     * @memberof POL
     */
    'pnl': string;
    /**
     * current amount of rune deposited
     * @type {string}
     * @memberof POL
     */
    'current_deposit': string;
}
/**
 * 
 * @export
 * @interface Ping
 */
export interface Ping {
    /**
     * 
     * @type {string}
     * @memberof Ping
     */
    'ping'?: string;
}
/**
 * 
 * @export
 * @interface PlannedOutTx
 */
export interface PlannedOutTx {
    /**
     * 
     * @type {string}
     * @memberof PlannedOutTx
     */
    'chain': string;
    /**
     * 
     * @type {string}
     * @memberof PlannedOutTx
     */
    'to_address': string;
    /**
     * 
     * @type {Coin}
     * @memberof PlannedOutTx
     */
    'coin': Coin;
    /**
     * returns true if the planned transaction has a refund memo
     * @type {boolean}
     * @memberof PlannedOutTx
     */
    'refund': boolean;
}
/**
 * 
 * @export
 * @interface Pool
 */
export interface Pool {
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'short_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'decimals'?: number;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'pending_inbound_asset': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'pending_inbound_rune': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'balance_asset': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'balance_rune': string;
    /**
     * the USD (TOR) price of the asset in 1e8
     * @type {string}
     * @memberof Pool
     */
    'asset_tor_price': string;
    /**
     * the total pool units, this is the sum of LP and synth units
     * @type {string}
     * @memberof Pool
     */
    'pool_units': string;
    /**
     * the total pool liquidity provider units
     * @type {string}
     * @memberof Pool
     */
    'LP_units': string;
    /**
     * the total synth units in the pool
     * @type {string}
     * @memberof Pool
     */
    'synth_units': string;
    /**
     * the total supply of synths for the asset
     * @type {string}
     * @memberof Pool
     */
    'synth_supply': string;
    /**
     * the balance of L1 asset deposited into the Savers Vault
     * @type {string}
     * @memberof Pool
     */
    'savers_depth': string;
    /**
     * the number of units owned by Savers
     * @type {string}
     * @memberof Pool
     */
    'savers_units': string;
    /**
     * the filled savers capacity in basis points, 4500/10000 = 45%
     * @type {string}
     * @memberof Pool
     */
    'savers_fill_bps': string;
    /**
     * amount of remaining capacity in asset
     * @type {string}
     * @memberof Pool
     */
    'savers_capacity_remaining': string;
    /**
     * whether additional synths cannot be minted
     * @type {boolean}
     * @memberof Pool
     */
    'synth_mint_paused': boolean;
    /**
     * the amount of synth supply remaining before the current max supply is reached
     * @type {string}
     * @memberof Pool
     */
    'synth_supply_remaining': string;
    /**
     * the amount of collateral collects for loans
     * @type {string}
     * @memberof Pool
     */
    'loan_collateral': string;
    /**
     * the amount of remaining collateral collects for loans
     * @type {string}
     * @memberof Pool
     */
    'loan_collateral_remaining': string;
    /**
     * the current loan collateralization ratio
     * @type {string}
     * @memberof Pool
     */
    'loan_cr': string;
    /**
     * the depth of the derived virtual pool relative to L1 pool (in basis points)
     * @type {string}
     * @memberof Pool
     */
    'derived_depth_bps': string;
}
/**
 * 
 * @export
 * @interface PoolSlipResponse
 */
export interface PoolSlipResponse extends Array<PoolSlipResponseInner> {
}
/**
 * 
 * @export
 * @interface PoolSlipResponseInner
 */
export interface PoolSlipResponseInner {
    /**
     * 
     * @type {string}
     * @memberof PoolSlipResponseInner
     */
    'asset': string;
    /**
     * Pool slip for this asset\'s pool for the current height
     * @type {number}
     * @memberof PoolSlipResponseInner
     */
    'pool_slip': number;
    /**
     * Number of stored pool slips contributing to the current stored rollup
     * @type {number}
     * @memberof PoolSlipResponseInner
     */
    'rollup_count': number;
    /**
     * Median of rollup snapshots over a long period
     * @type {number}
     * @memberof PoolSlipResponseInner
     */
    'long_rollup': number;
    /**
     * Stored sum of pool slips over a number of previous block heights
     * @type {number}
     * @memberof PoolSlipResponseInner
     */
    'rollup': number;
    /**
     * Summed pool slips over a number of previous block heights, to checksum the stored rollup
     * @type {number}
     * @memberof PoolSlipResponseInner
     */
    'summed_rollup'?: number;
}
/**
 * 
 * @export
 * @interface PoolsResponse
 */
export interface PoolsResponse extends Array<Pool> {
}
/**
 * 
 * @export
 * @interface QueueResponse
 */
export interface QueueResponse {
    /**
     * 
     * @type {number}
     * @memberof QueueResponse
     */
    'swap': number;
    /**
     * number of signed outbound tx in the queue
     * @type {number}
     * @memberof QueueResponse
     */
    'outbound': number;
    /**
     * 
     * @type {number}
     * @memberof QueueResponse
     */
    'internal': number;
    /**
     * scheduled outbound value in RUNE
     * @type {string}
     * @memberof QueueResponse
     */
    'scheduled_outbound_value': string;
    /**
     * scheduled outbound clout in RUNE
     * @type {string}
     * @memberof QueueResponse
     */
    'scheduled_outbound_clout': string;
}
/**
 * 
 * @export
 * @interface QuoteFees
 */
export interface QuoteFees {
    /**
     * the target asset used for all fees
     * @type {string}
     * @memberof QuoteFees
     */
    'asset': string;
    /**
     * affiliate fee in the target asset
     * @type {string}
     * @memberof QuoteFees
     */
    'affiliate'?: string;
    /**
     * outbound fee in the target asset
     * @type {string}
     * @memberof QuoteFees
     */
    'outbound'?: string;
    /**
     * liquidity fees paid to pools in the target asset
     * @type {string}
     * @memberof QuoteFees
     */
    'liquidity': string;
    /**
     * total fees in the target asset
     * @type {string}
     * @memberof QuoteFees
     */
    'total': string;
    /**
     * the swap slippage in basis points
     * @type {number}
     * @memberof QuoteFees
     */
    'slippage_bps': number;
    /**
     * total basis points in fees relative to amount out
     * @type {number}
     * @memberof QuoteFees
     */
    'total_bps': number;
}
/**
 * 
 * @export
 * @interface QuoteLoanCloseResponse
 */
export interface QuoteLoanCloseResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'inbound_address'?: string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of thorchain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'outbound_delay_blocks': number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'outbound_delay_seconds': number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteLoanCloseResponse
     */
    'fees': QuoteFees;
    /**
     * the EVM chain router contract address
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'router'?: string;
    /**
     * expiration timestamp in unix seconds
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'expiry': number;
    /**
     * static warning message
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'warning': string;
    /**
     * chain specific quote notes
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'notes': string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'dust_threshold'?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'recommended_min_amount_in'?: string;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'recommended_gas_rate'?: string;
    /**
     * the units of the recommended gas rate
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'gas_rate_units'?: string;
    /**
     * generated memo for the loan close
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'memo': string;
    /**
     * the amount of collateral asset the user can expect to receive after fees in 1e8 decimals
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'expected_amount_out': string;
    /**
     * The quantity of the repayment asset to be sent by the user, calculated as the desired percentage of the loan\'s value, expressed in units of 1e8
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'expected_amount_in': string;
    /**
     * the expected amount of collateral decrease on the loan
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'expected_collateral_withdrawn': string;
    /**
     * the expected amount of TOR debt decrease on the loan
     * @type {string}
     * @memberof QuoteLoanCloseResponse
     */
    'expected_debt_repaid': string;
    /**
     * The number of blocks involved in the streaming swaps during the repayment process.
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'streaming_swap_blocks': number;
    /**
     * The approximate number of seconds taken by the streaming swaps involved in the repayment process.
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'streaming_swap_seconds': number;
    /**
     * The total expected duration for a repayment, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
     * @type {number}
     * @memberof QuoteLoanCloseResponse
     */
    'total_repay_seconds': number;
}
/**
 * 
 * @export
 * @interface QuoteLoanOpenResponse
 */
export interface QuoteLoanOpenResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'inbound_address'?: string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of thorchain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'outbound_delay_blocks': number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'outbound_delay_seconds': number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteLoanOpenResponse
     */
    'fees': QuoteFees;
    /**
     * the EVM chain router contract address
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'router'?: string;
    /**
     * expiration timestamp in unix seconds
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'expiry': number;
    /**
     * static warning message
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'warning': string;
    /**
     * chain specific quote notes
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'notes': string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'dust_threshold'?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'recommended_min_amount_in'?: string;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'recommended_gas_rate': string;
    /**
     * the units of the recommended gas rate
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'gas_rate_units': string;
    /**
     * generated memo for the loan open
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'memo'?: string;
    /**
     * the amount of the target asset the user can expect to receive after fees in 1e8 decimals
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'expected_amount_out': string;
    /**
     * the expected collateralization ratio in basis points
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'expected_collateralization_ratio': string;
    /**
     * the expected amount of collateral increase on the loan
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'expected_collateral_deposited': string;
    /**
     * the expected amount of TOR debt increase on the loan
     * @type {string}
     * @memberof QuoteLoanOpenResponse
     */
    'expected_debt_issued': string;
    /**
     * The number of blocks involved in the streaming swaps during the open loan process.
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'streaming_swap_blocks': number;
    /**
     * The approximate number of seconds taken by the streaming swaps involved in the open loan process.
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'streaming_swap_seconds': number;
    /**
     * The total expected duration for a open loan, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
     * @type {number}
     * @memberof QuoteLoanOpenResponse
     */
    'total_open_loan_seconds': number;
}
/**
 * 
 * @export
 * @interface QuoteSaverDepositResponse
 */
export interface QuoteSaverDepositResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'inbound_address': string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of thorchain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'outbound_delay_blocks'?: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'outbound_delay_seconds'?: number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteSaverDepositResponse
     */
    'fees': QuoteFees;
    /**
     * the EVM chain router contract address
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'router'?: string;
    /**
     * expiration timestamp in unix seconds
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'expiry': number;
    /**
     * static warning message
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'warning': string;
    /**
     * chain specific quote notes
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'notes': string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'dust_threshold'?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'recommended_min_amount_in'?: string;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'recommended_gas_rate': string;
    /**
     * the units of the recommended gas rate
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'gas_rate_units': string;
    /**
     * generated memo for the deposit
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'memo': string;
    /**
     * same as expected_amount_deposit, to be deprecated in favour of expected_amount_deposit
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'expected_amount_out'?: string;
    /**
     * the amount of the target asset the user can expect to deposit after fees
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'expected_amount_deposit': string;
}
/**
 * 
 * @export
 * @interface QuoteSaverWithdrawResponse
 */
export interface QuoteSaverWithdrawResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'inbound_address': string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of thorchain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'outbound_delay_blocks': number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'outbound_delay_seconds': number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteSaverWithdrawResponse
     */
    'fees': QuoteFees;
    /**
     * the EVM chain router contract address
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'router'?: string;
    /**
     * expiration timestamp in unix seconds
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'expiry': number;
    /**
     * static warning message
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'warning': string;
    /**
     * chain specific quote notes
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'notes': string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'dust_threshold'?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'recommended_min_amount_in'?: string;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'recommended_gas_rate': string;
    /**
     * the units of the recommended gas rate
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'gas_rate_units': string;
    /**
     * generated memo for the withdraw, the client can use this OR send the dust amount
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'memo': string;
    /**
     * the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'dust_amount': string;
    /**
     * the amount of the target asset the user can expect to withdraw after fees in 1e8 decimals
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'expected_amount_out': string;
}
/**
 * 
 * @export
 * @interface QuoteSwapResponse
 */
export interface QuoteSwapResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'inbound_address'?: string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of thorchain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'outbound_delay_blocks': number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'outbound_delay_seconds': number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteSwapResponse
     */
    'fees': QuoteFees;
    /**
     * the EVM chain router contract address
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'router'?: string;
    /**
     * expiration timestamp in unix seconds
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'expiry': number;
    /**
     * static warning message
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'warning': string;
    /**
     * chain specific quote notes
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'notes': string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'dust_threshold'?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'recommended_min_amount_in'?: string;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'recommended_gas_rate'?: string;
    /**
     * the units of the recommended gas rate
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'gas_rate_units'?: string;
    /**
     * generated memo for the swap
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'memo'?: string;
    /**
     * the amount of the target asset the user can expect to receive after fees
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'expected_amount_out': string;
    /**
     * the maximum amount of trades a streaming swap can do for a trade
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'max_streaming_quantity'?: number;
    /**
     * the number of blocks the streaming swap will execute over
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'streaming_swap_blocks'?: number;
    /**
     * approx the number of seconds the streaming swap will execute over
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'streaming_swap_seconds'?: number;
    /**
     * total number of seconds a swap is expected to take (inbound conf + streaming swap + outbound delay)
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'total_swap_seconds'?: number;
}
/**
 * 
 * @export
 * @interface RUNEPoolResponse
 */
export interface RUNEPoolResponse {
    /**
     * 
     * @type {POL}
     * @memberof RUNEPoolResponse
     */
    'pol': POL;
    /**
     * 
     * @type {RUNEPoolResponseProviders}
     * @memberof RUNEPoolResponse
     */
    'providers': RUNEPoolResponseProviders;
    /**
     * 
     * @type {RUNEPoolResponseReserve}
     * @memberof RUNEPoolResponse
     */
    'reserve': RUNEPoolResponseReserve;
}
/**
 * 
 * @export
 * @interface RUNEPoolResponseProviders
 */
export interface RUNEPoolResponseProviders {
    /**
     * the units of RUNEPool owned by providers (including pending)
     * @type {string}
     * @memberof RUNEPoolResponseProviders
     */
    'units': string;
    /**
     * the units of RUNEPool owned by providers that remain pending
     * @type {string}
     * @memberof RUNEPoolResponseProviders
     */
    'pending_units': string;
    /**
     * the amount of RUNE pending
     * @type {string}
     * @memberof RUNEPoolResponseProviders
     */
    'pending_rune': string;
    /**
     * the value of the provider share of the RUNEPool (includes pending RUNE)
     * @type {string}
     * @memberof RUNEPoolResponseProviders
     */
    'value': string;
    /**
     * the profit and loss of the provider share of the RUNEPool
     * @type {string}
     * @memberof RUNEPoolResponseProviders
     */
    'pnl': string;
    /**
     * the current RUNE deposited by providers
     * @type {string}
     * @memberof RUNEPoolResponseProviders
     */
    'current_deposit': string;
}
/**
 * 
 * @export
 * @interface RUNEPoolResponseReserve
 */
export interface RUNEPoolResponseReserve {
    /**
     * the units of RUNEPool owned by the reserve
     * @type {string}
     * @memberof RUNEPoolResponseReserve
     */
    'units': string;
    /**
     * the value of the reserve share of the RUNEPool
     * @type {string}
     * @memberof RUNEPoolResponseReserve
     */
    'value': string;
    /**
     * the profit and loss of the reserve share of the RUNEPool
     * @type {string}
     * @memberof RUNEPoolResponseReserve
     */
    'pnl': string;
    /**
     * the current RUNE deposited by the reserve
     * @type {string}
     * @memberof RUNEPoolResponseReserve
     */
    'current_deposit': string;
}
/**
 * 
 * @export
 * @interface RUNEProvider
 */
export interface RUNEProvider {
    /**
     * 
     * @type {string}
     * @memberof RUNEProvider
     */
    'rune_address': string;
    /**
     * 
     * @type {string}
     * @memberof RUNEProvider
     */
    'units': string;
    /**
     * 
     * @type {string}
     * @memberof RUNEProvider
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof RUNEProvider
     */
    'pnl': string;
    /**
     * 
     * @type {string}
     * @memberof RUNEProvider
     */
    'deposit_amount': string;
    /**
     * 
     * @type {string}
     * @memberof RUNEProvider
     */
    'withdraw_amount': string;
    /**
     * 
     * @type {number}
     * @memberof RUNEProvider
     */
    'last_deposit_height': number;
    /**
     * 
     * @type {number}
     * @memberof RUNEProvider
     */
    'last_withdraw_height': number;
}
/**
 * 
 * @export
 * @interface RUNEProvidersResponse
 */
export interface RUNEProvidersResponse extends Array<RUNEProvider> {
}
/**
 * 
 * @export
 * @interface Saver
 */
export interface Saver {
    /**
     * 
     * @type {string}
     * @memberof Saver
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof Saver
     */
    'asset_address': string;
    /**
     * 
     * @type {number}
     * @memberof Saver
     */
    'last_add_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof Saver
     */
    'last_withdraw_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Saver
     */
    'units': string;
    /**
     * 
     * @type {string}
     * @memberof Saver
     */
    'asset_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof Saver
     */
    'asset_redeem_value': string;
    /**
     * 
     * @type {string}
     * @memberof Saver
     */
    'growth_pct': string;
}
/**
 * 
 * @export
 * @interface SaversResponse
 */
export interface SaversResponse extends Array<Saver> {
}
/**
 * 
 * @export
 * @interface ScheduledResponse
 */
export interface ScheduledResponse extends Array<TxOutItem> {
}
/**
 * 
 * @export
 * @interface StreamingStatus
 */
export interface StreamingStatus {
    /**
     * how often each swap is made, in blocks
     * @type {number}
     * @memberof StreamingStatus
     */
    'interval': number;
    /**
     * the total number of swaps in a streaming swaps
     * @type {number}
     * @memberof StreamingStatus
     */
    'quantity': number;
    /**
     * the amount of swap attempts so far
     * @type {number}
     * @memberof StreamingStatus
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface StreamingSwap
 */
export interface StreamingSwap {
    /**
     * the hash of a transaction
     * @type {string}
     * @memberof StreamingSwap
     */
    'tx_id'?: string;
    /**
     * how often each swap is made, in blocks
     * @type {number}
     * @memberof StreamingSwap
     */
    'interval'?: number;
    /**
     * the total number of swaps in a streaming swaps
     * @type {number}
     * @memberof StreamingSwap
     */
    'quantity'?: number;
    /**
     * the amount of swap attempts so far
     * @type {number}
     * @memberof StreamingSwap
     */
    'count'?: number;
    /**
     * the block height of the latest swap
     * @type {number}
     * @memberof StreamingSwap
     */
    'last_height'?: number;
    /**
     * the total number of tokens the swapper wants to receive of the output asset
     * @type {string}
     * @memberof StreamingSwap
     */
    'trade_target': string;
    /**
     * the asset to be swapped from
     * @type {string}
     * @memberof StreamingSwap
     */
    'source_asset'?: string;
    /**
     * the asset to be swapped to
     * @type {string}
     * @memberof StreamingSwap
     */
    'target_asset'?: string;
    /**
     * the destination address to receive the swap output
     * @type {string}
     * @memberof StreamingSwap
     */
    'destination'?: string;
    /**
     * the number of input tokens the swapper has deposited
     * @type {string}
     * @memberof StreamingSwap
     */
    'deposit': string;
    /**
     * the amount of input tokens that have been swapped so far
     * @type {string}
     * @memberof StreamingSwap
     */
    'in': string;
    /**
     * the amount of output tokens that have been swapped so far
     * @type {string}
     * @memberof StreamingSwap
     */
    'out': string;
    /**
     * the list of swap indexes that failed
     * @type {Array<number>}
     * @memberof StreamingSwap
     */
    'failed_swaps'?: Array<number>;
    /**
     * the list of reasons that sub-swaps have failed
     * @type {Array<string>}
     * @memberof StreamingSwap
     */
    'failed_swap_reasons'?: Array<string>;
}
/**
 * 
 * @export
 * @interface StreamingSwapsResponse
 */
export interface StreamingSwapsResponse extends Array<StreamingSwap> {
}
/**
 * 
 * @export
 * @interface SwapFinalisedStage
 */
export interface SwapFinalisedStage {
    /**
     * (to be deprecated in favor of swap_status) returns true if an inbound transaction\'s swap (successful or refunded) is no longer pending
     * @type {boolean}
     * @memberof SwapFinalisedStage
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface SwapQueueResponse
 */
export interface SwapQueueResponse extends Array<MsgSwap> {
}
/**
 * 
 * @export
 * @interface SwapStatus
 */
export interface SwapStatus {
    /**
     * true when awaiting a swap
     * @type {boolean}
     * @memberof SwapStatus
     */
    'pending': boolean;
    /**
     * 
     * @type {StreamingStatus}
     * @memberof SwapStatus
     */
    'streaming'?: StreamingStatus;
}
/**
 * 
 * @export
 * @interface SwapperCloutResponse
 */
export interface SwapperCloutResponse {
    /**
     * address associated with this clout account
     * @type {string}
     * @memberof SwapperCloutResponse
     */
    'address': string;
    /**
     * clout score, which is the amount of rune spent on swap fees
     * @type {string}
     * @memberof SwapperCloutResponse
     */
    'score'?: string;
    /**
     * amount of clout that has been reclaimed in total over time (observed clout spent)
     * @type {string}
     * @memberof SwapperCloutResponse
     */
    'reclaimed'?: string;
    /**
     * amount of clout that has been spent in total over time
     * @type {string}
     * @memberof SwapperCloutResponse
     */
    'spent'?: string;
    /**
     * last block height that clout was spent
     * @type {number}
     * @memberof SwapperCloutResponse
     */
    'last_spent_height'?: number;
    /**
     * last block height that clout was reclaimed
     * @type {number}
     * @memberof SwapperCloutResponse
     */
    'last_reclaim_height'?: number;
}
/**
 * 
 * @export
 * @interface Thorname
 */
export interface Thorname {
    /**
     * 
     * @type {string}
     * @memberof Thorname
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Thorname
     */
    'expire_block_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Thorname
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof Thorname
     */
    'preferred_asset': string;
    /**
     * Amount of RUNE currently accrued by this thorname in affiliate fees waiting to be swapped to preferred asset.
     * @type {string}
     * @memberof Thorname
     */
    'affiliate_collector_rune'?: string;
    /**
     * 
     * @type {Array<ThornameAlias>}
     * @memberof Thorname
     */
    'aliases': Array<ThornameAlias>;
}
/**
 * 
 * @export
 * @interface ThornameAlias
 */
export interface ThornameAlias {
    /**
     * 
     * @type {string}
     * @memberof ThornameAlias
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof ThornameAlias
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface TradeAccountResponse
 */
export interface TradeAccountResponse {
    /**
     * trade account asset with \"~\" separator
     * @type {string}
     * @memberof TradeAccountResponse
     */
    'asset': string;
    /**
     * units of trade asset belonging to this owner
     * @type {string}
     * @memberof TradeAccountResponse
     */
    'units': string;
    /**
     * thor address of trade account owner
     * @type {string}
     * @memberof TradeAccountResponse
     */
    'owner': string;
    /**
     * last thorchain height trade assets were added to trade account
     * @type {number}
     * @memberof TradeAccountResponse
     */
    'last_add_height'?: number;
    /**
     * last thorchain height trade assets were withdrawn from trade account
     * @type {number}
     * @memberof TradeAccountResponse
     */
    'last_withdraw_height'?: number;
}
/**
 * 
 * @export
 * @interface TradeAccountsResponse
 */
export interface TradeAccountsResponse extends Array<TradeAccountResponse> {
}
/**
 * 
 * @export
 * @interface TradeUnitResponse
 */
export interface TradeUnitResponse {
    /**
     * trade account asset with \"~\" separator
     * @type {string}
     * @memberof TradeUnitResponse
     */
    'asset': string;
    /**
     * total units of trade asset
     * @type {string}
     * @memberof TradeUnitResponse
     */
    'units': string;
    /**
     * total depth of trade asset
     * @type {string}
     * @memberof TradeUnitResponse
     */
    'depth': string;
}
/**
 * 
 * @export
 * @interface TradeUnitsResponse
 */
export interface TradeUnitsResponse extends Array<TradeUnitResponse> {
}
/**
 * 
 * @export
 * @interface TssKeysignMetric
 */
export interface TssKeysignMetric {
    /**
     * 
     * @type {string}
     * @memberof TssKeysignMetric
     */
    'tx_id'?: string;
    /**
     * 
     * @type {Array<TssMetric>}
     * @memberof TssKeysignMetric
     */
    'node_tss_times': Array<TssMetric>;
}
/**
 * 
 * @export
 * @interface TssMetric
 */
export interface TssMetric {
    /**
     * 
     * @type {string}
     * @memberof TssMetric
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof TssMetric
     */
    'tss_time'?: number;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'from_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'to_address'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    'gas': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface TxDetailsResponse
 */
export interface TxDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof TxDetailsResponse
     */
    'tx_id'?: string;
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxDetailsResponse
     */
    'tx': ObservedTx;
    /**
     * 
     * @type {Array<ObservedTx>}
     * @memberof TxDetailsResponse
     */
    'txs': Array<ObservedTx>;
    /**
     * 
     * @type {Array<TxOutItem>}
     * @memberof TxDetailsResponse
     */
    'actions': Array<TxOutItem>;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxDetailsResponse
     */
    'out_txs': Array<Tx>;
    /**
     * the thorchain height at which the inbound reached consensus
     * @type {number}
     * @memberof TxDetailsResponse
     */
    'consensus_height'?: number;
    /**
     * the thorchain height at which the outbound was finalised
     * @type {number}
     * @memberof TxDetailsResponse
     */
    'finalised_height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TxDetailsResponse
     */
    'updated_vault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TxDetailsResponse
     */
    'reverted'?: boolean;
    /**
     * the thorchain height for which the outbound was scheduled
     * @type {number}
     * @memberof TxDetailsResponse
     */
    'outbound_height'?: number;
}
/**
 * 
 * @export
 * @interface TxOutItem
 */
export interface TxOutItem {
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'chain': string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'to_address': string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'vault_pub_key'?: string;
    /**
     * 
     * @type {Coin}
     * @memberof TxOutItem
     */
    'coin': Coin;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'memo'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof TxOutItem
     */
    'max_gas': Array<Coin>;
    /**
     * 
     * @type {number}
     * @memberof TxOutItem
     */
    'gas_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'in_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'out_hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxOutItem
     */
    'height'?: number;
    /**
     * clout spent in RUNE for the outbound
     * @type {string}
     * @memberof TxOutItem
     */
    'clout_spent'?: string;
}
/**
 * 
 * @export
 * @interface TxResponse
 */
export interface TxResponse {
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxResponse
     */
    'observed_tx'?: ObservedTx;
    /**
     * the thorchain height at which the inbound reached consensus
     * @type {number}
     * @memberof TxResponse
     */
    'consensus_height'?: number;
    /**
     * the thorchain height at which the outbound was finalised
     * @type {number}
     * @memberof TxResponse
     */
    'finalised_height'?: number;
    /**
     * the thorchain height for which the outbound was scheduled
     * @type {number}
     * @memberof TxResponse
     */
    'outbound_height'?: number;
    /**
     * 
     * @type {TssKeysignMetric}
     * @memberof TxResponse
     */
    'keysign_metric'?: TssKeysignMetric;
}
/**
 * 
 * @export
 * @interface TxSignersResponse
 */
export interface TxSignersResponse {
    /**
     * 
     * @type {string}
     * @memberof TxSignersResponse
     */
    'tx_id'?: string;
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxSignersResponse
     */
    'tx': ObservedTx;
    /**
     * 
     * @type {Array<ObservedTx>}
     * @memberof TxSignersResponse
     */
    'txs': Array<ObservedTx>;
    /**
     * 
     * @type {Array<TxOutItem>}
     * @memberof TxSignersResponse
     */
    'actions': Array<TxOutItem>;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxSignersResponse
     */
    'out_txs': Array<Tx>;
    /**
     * the thorchain height at which the inbound reached consensus
     * @type {number}
     * @memberof TxSignersResponse
     */
    'consensus_height'?: number;
    /**
     * the thorchain height at which the outbound was finalised
     * @type {number}
     * @memberof TxSignersResponse
     */
    'finalised_height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TxSignersResponse
     */
    'updated_vault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TxSignersResponse
     */
    'reverted'?: boolean;
    /**
     * the thorchain height for which the outbound was scheduled
     * @type {number}
     * @memberof TxSignersResponse
     */
    'outbound_height'?: number;
}
/**
 * 
 * @export
 * @interface TxStagesResponse
 */
export interface TxStagesResponse {
    /**
     * 
     * @type {InboundObservedStage}
     * @memberof TxStagesResponse
     */
    'inbound_observed': InboundObservedStage;
    /**
     * 
     * @type {InboundConfirmationCountedStage}
     * @memberof TxStagesResponse
     */
    'inbound_confirmation_counted'?: InboundConfirmationCountedStage;
    /**
     * 
     * @type {InboundFinalisedStage}
     * @memberof TxStagesResponse
     */
    'inbound_finalised'?: InboundFinalisedStage;
    /**
     * 
     * @type {SwapStatus}
     * @memberof TxStagesResponse
     */
    'swap_status'?: SwapStatus;
    /**
     * 
     * @type {SwapFinalisedStage}
     * @memberof TxStagesResponse
     */
    'swap_finalised'?: SwapFinalisedStage;
    /**
     * 
     * @type {OutboundDelayStage}
     * @memberof TxStagesResponse
     */
    'outbound_delay'?: OutboundDelayStage;
    /**
     * 
     * @type {OutboundSignedStage}
     * @memberof TxStagesResponse
     */
    'outbound_signed'?: OutboundSignedStage;
}
/**
 * 
 * @export
 * @interface TxStatusResponse
 */
export interface TxStatusResponse {
    /**
     * 
     * @type {Tx}
     * @memberof TxStatusResponse
     */
    'tx'?: Tx;
    /**
     * 
     * @type {Array<PlannedOutTx>}
     * @memberof TxStatusResponse
     */
    'planned_out_txs'?: Array<PlannedOutTx>;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxStatusResponse
     */
    'out_txs'?: Array<Tx>;
    /**
     * 
     * @type {TxStagesResponse}
     * @memberof TxStatusResponse
     */
    'stages': TxStagesResponse;
}
/**
 * 
 * @export
 * @interface Vault
 */
export interface Vault {
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'block_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Vault
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'type'?: VaultTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'status_since'?: number;
    /**
     * the list of node public keys which are members of the vault
     * @type {Array<string>}
     * @memberof Vault
     */
    'membership'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vault
     */
    'chains'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'inbound_tx_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'outbound_tx_count'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Vault
     */
    'pending_tx_block_heights'?: Array<number>;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof Vault
     */
    'routers': Array<VaultRouter>;
    /**
     * 
     * @type {Array<VaultAddress>}
     * @memberof Vault
     */
    'addresses': Array<VaultAddress>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vault
     */
    'frozen'?: Array<string>;
}

export const VaultTypeEnum = {
    AsgardVault: 'AsgardVault',
    YggdrasilVault: 'YggdrasilVault'
} as const;

export type VaultTypeEnum = typeof VaultTypeEnum[keyof typeof VaultTypeEnum];

/**
 * 
 * @export
 * @interface VaultAddress
 */
export interface VaultAddress {
    /**
     * 
     * @type {string}
     * @memberof VaultAddress
     */
    'chain': string;
    /**
     * 
     * @type {string}
     * @memberof VaultAddress
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface VaultInfo
 */
export interface VaultInfo {
    /**
     * 
     * @type {string}
     * @memberof VaultInfo
     */
    'pub_key': string;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof VaultInfo
     */
    'routers': Array<VaultRouter>;
}
/**
 * 
 * @export
 * @interface VaultPubkeysResponse
 */
export interface VaultPubkeysResponse {
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'asgard': Array<VaultInfo>;
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'yggdrasil': Array<VaultInfo>;
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'inactive': Array<VaultInfo>;
}
/**
 * 
 * @export
 * @interface VaultRouter
 */
export interface VaultRouter {
    /**
     * 
     * @type {string}
     * @memberof VaultRouter
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultRouter
     */
    'router'?: string;
}
/**
 * 
 * @export
 * @interface VaultsResponse
 */
export interface VaultsResponse extends Array<Vault> {
}
/**
 * 
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
    /**
     * current version
     * @type {string}
     * @memberof VersionResponse
     */
    'current': string;
    /**
     * next version (minimum version for a node to become Active)
     * @type {string}
     * @memberof VersionResponse
     */
    'next': string;
    /**
     * height at which the minimum joining version last changed
     * @type {number}
     * @memberof VersionResponse
     */
    'next_since_height'?: number;
    /**
     * querier version
     * @type {string}
     * @memberof VersionResponse
     */
    'querier': string;
}
/**
 * 
 * @export
 * @interface YggdrasilVault
 */
export interface YggdrasilVault {
    /**
     * 
     * @type {number}
     * @memberof YggdrasilVault
     */
    'block_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof YggdrasilVault
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof YggdrasilVault
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof YggdrasilVault
     */
    'type'?: YggdrasilVaultTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof YggdrasilVault
     */
    'status_since'?: number;
    /**
     * the list of node public keys which are members of the vault
     * @type {Array<string>}
     * @memberof YggdrasilVault
     */
    'membership'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof YggdrasilVault
     */
    'chains'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof YggdrasilVault
     */
    'inbound_tx_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof YggdrasilVault
     */
    'outbound_tx_count'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof YggdrasilVault
     */
    'pending_tx_block_heights'?: Array<number>;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof YggdrasilVault
     */
    'routers': Array<VaultRouter>;
    /**
     * 
     * @type {string}
     * @memberof YggdrasilVault
     */
    'status': string;
    /**
     * current node bond
     * @type {string}
     * @memberof YggdrasilVault
     */
    'bond': string;
    /**
     * value in rune of the vault\'s assets
     * @type {string}
     * @memberof YggdrasilVault
     */
    'total_value': string;
    /**
     * 
     * @type {Array<VaultAddress>}
     * @memberof YggdrasilVault
     */
    'addresses': Array<VaultAddress>;
}

export const YggdrasilVaultTypeEnum = {
    AsgardVault: 'AsgardVault',
    YggdrasilVault: 'YggdrasilVault'
} as const;

export type YggdrasilVaultTypeEnum = typeof YggdrasilVaultTypeEnum[keyof typeof YggdrasilVaultTypeEnum];

/**
 * 
 * @export
 * @interface YggdrasilVaultsResponse
 */
export interface YggdrasilVaultsResponse extends Array<YggdrasilVault> {
}

/**
 * BlockApi - axios parameter creator
 * @export
 */
export const BlockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns verbose details of the block.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 * @export
 */
export const BlockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns verbose details of the block.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async block(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.block(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockApi - factory interface
 * @export
 */
export const BlockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockApiFp(configuration)
    return {
        /**
         * Returns verbose details of the block.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(height?: number, options?: any): AxiosPromise<BlockResponse> {
            return localVarFp.block(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
export class BlockApi extends BaseAPI {
    /**
     * Returns verbose details of the block.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public block(height?: number, options?: AxiosRequestConfig) {
        return BlockApiFp(this.configuration).block(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BorrowersApi - axios parameter creator
 * @export
 */
export const BorrowersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the borrower position given the pool and address.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        borrower: async (asset: string, address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('borrower', 'asset', asset)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('borrower', 'address', address)
            const localVarPath = `/thorchain/pool/{asset}/borrower/{address}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all borrowers for the given pool.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        borrowers: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('borrowers', 'asset', asset)
            const localVarPath = `/thorchain/pool/{asset}/borrowers`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BorrowersApi - functional programming interface
 * @export
 */
export const BorrowersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BorrowersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the borrower position given the pool and address.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async borrower(asset: string, address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Borrower>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.borrower(asset, address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all borrowers for the given pool.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async borrowers(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BorrowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.borrowers(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BorrowersApi - factory interface
 * @export
 */
export const BorrowersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BorrowersApiFp(configuration)
    return {
        /**
         * Returns the borrower position given the pool and address.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        borrower(asset: string, address: string, height?: number, options?: any): AxiosPromise<Borrower> {
            return localVarFp.borrower(asset, address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all borrowers for the given pool.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        borrowers(asset: string, height?: number, options?: any): AxiosPromise<BorrowersResponse> {
            return localVarFp.borrowers(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BorrowersApi - object-oriented interface
 * @export
 * @class BorrowersApi
 * @extends {BaseAPI}
 */
export class BorrowersApi extends BaseAPI {
    /**
     * Returns the borrower position given the pool and address.
     * @param {string} asset 
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrowersApi
     */
    public borrower(asset: string, address: string, height?: number, options?: AxiosRequestConfig) {
        return BorrowersApiFp(this.configuration).borrower(asset, address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all borrowers for the given pool.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BorrowersApi
     */
    public borrowers(asset: string, height?: number, options?: AxiosRequestConfig) {
        return BorrowersApiFp(this.configuration).borrowers(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloutApi - axios parameter creator
 * @export
 */
export const CloutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the clout score of an address
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapperClout: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('swapperClout', 'address', address)
            const localVarPath = `/thorchain/clout/swap/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloutApi - functional programming interface
 * @export
 */
export const CloutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloutApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the clout score of an address
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swapperClout(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwapperCloutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swapperClout(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloutApi - factory interface
 * @export
 */
export const CloutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloutApiFp(configuration)
    return {
        /**
         * Returns the clout score of an address
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapperClout(address: string, height?: number, options?: any): AxiosPromise<SwapperCloutResponse> {
            return localVarFp.swapperClout(address, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloutApi - object-oriented interface
 * @export
 * @class CloutApi
 * @extends {BaseAPI}
 */
export class CloutApi extends BaseAPI {
    /**
     * Returns the clout score of an address
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloutApi
     */
    public swapperClout(address: string, height?: number, options?: AxiosRequestConfig) {
        return CloutApiFp(this.configuration).swapperClout(address, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<Ping> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvariantsApi - axios parameter creator
 * @export
 */
export const InvariantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns result of running the given invariant.
         * @param {string} invariant 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invariant: async (invariant: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invariant' is not null or undefined
            assertParamExists('invariant', 'invariant', invariant)
            const localVarPath = `/thorchain/invariant/{invariant}`
                .replace(`{${"invariant"}}`, encodeURIComponent(String(invariant)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available invariants.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invariants: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/invariants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvariantsApi - functional programming interface
 * @export
 */
export const InvariantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvariantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns result of running the given invariant.
         * @param {string} invariant 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invariant(invariant: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvariantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invariant(invariant, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of available invariants.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invariants(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvariantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invariants(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvariantsApi - factory interface
 * @export
 */
export const InvariantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvariantsApiFp(configuration)
    return {
        /**
         * Returns result of running the given invariant.
         * @param {string} invariant 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invariant(invariant: string, height?: number, options?: any): AxiosPromise<InvariantResponse> {
            return localVarFp.invariant(invariant, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available invariants.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invariants(height?: number, options?: any): AxiosPromise<InvariantsResponse> {
            return localVarFp.invariants(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvariantsApi - object-oriented interface
 * @export
 * @class InvariantsApi
 * @extends {BaseAPI}
 */
export class InvariantsApi extends BaseAPI {
    /**
     * Returns result of running the given invariant.
     * @param {string} invariant 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvariantsApi
     */
    public invariant(invariant: string, height?: number, options?: AxiosRequestConfig) {
        return InvariantsApiFp(this.configuration).invariant(invariant, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of available invariants.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvariantsApi
     */
    public invariants(height?: number, options?: AxiosRequestConfig) {
        return InvariantsApiFp(this.configuration).invariants(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiquidityProvidersApi - axios parameter creator
 * @export
 */
export const LiquidityProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider: async (asset: string, address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProvider', 'asset', asset)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('liquidityProvider', 'address', address)
            const localVarPath = `/thorchain/pool/{asset}/liquidity_provider/{address}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProviders', 'asset', asset)
            const localVarPath = `/thorchain/pool/{asset}/liquidity_providers`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiquidityProvidersApi - functional programming interface
 * @export
 */
export const LiquidityProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiquidityProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProvider(asset: string, address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProvider(asset, address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProviders(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviders(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LiquidityProvidersApi - factory interface
 * @export
 */
export const LiquidityProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiquidityProvidersApiFp(configuration)
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider(asset: string, address: string, height?: number, options?: any): AxiosPromise<LiquidityProvider> {
            return localVarFp.liquidityProvider(asset, address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders(asset: string, height?: number, options?: any): AxiosPromise<LiquidityProvidersResponse> {
            return localVarFp.liquidityProviders(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiquidityProvidersApi - object-oriented interface
 * @export
 * @class LiquidityProvidersApi
 * @extends {BaseAPI}
 */
export class LiquidityProvidersApi extends BaseAPI {
    /**
     * Returns the liquidity provider information for an address and asset.
     * @param {string} asset 
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    public liquidityProvider(asset: string, address: string, height?: number, options?: AxiosRequestConfig) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProvider(asset, address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all liquidity provider information for an asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    public liquidityProviders(asset: string, height?: number, options?: AxiosRequestConfig) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProviders(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MimirApi - axios parameter creator
 * @export
 */
export const MimirApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/mimir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/mimir/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey: async (key: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('mimirKey', 'key', key)
            const localVarPath = `/thorchain/mimir/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('mimirNode', 'address', address)
            const localVarPath = `/thorchain/mimir/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/mimir/nodes_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MimirApi - functional programming interface
 * @export
 */
export const MimirApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MimirApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimir(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimir(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirAdmin(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirAdmin(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirKey(key: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirKey(key, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirNode(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirNode(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirNodes(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirNodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirNodes(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MimirApi - factory interface
 * @export
 */
export const MimirApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MimirApiFp(configuration)
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir(height?: number, options?: any): AxiosPromise<MimirResponse> {
            return localVarFp.mimir(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin(height?: number, options?: any): AxiosPromise<MimirResponse> {
            return localVarFp.mimirAdmin(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey(key: string, height?: number, options?: any): AxiosPromise<number> {
            return localVarFp.mimirKey(key, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode(address: string, height?: number, options?: any): AxiosPromise<MimirResponse> {
            return localVarFp.mimirNode(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes(height?: number, options?: any): AxiosPromise<MimirNodesResponse> {
            return localVarFp.mimirNodes(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MimirApi - object-oriented interface
 * @export
 * @class MimirApi
 * @extends {BaseAPI}
 */
export class MimirApi extends BaseAPI {
    /**
     * Returns current active mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimir(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimir(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current admin mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirAdmin(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirAdmin(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current active mimir configuration for the provided key.
     * @param {string} key the mimir key to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirKey(key: string, height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirKey(key, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current node mimir configuration for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirNode(address: string, height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirNode(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current node mimir votes.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirNodes(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirNodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('ban', 'address', address)
            const localVarPath = `/thorchain/ban/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain: async (chain: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('lastblockChain', 'chain', chain)
            const localVarPath = `/thorchain/lastblock/{chain}`
                .replace(`{${"chain"}}`, encodeURIComponent(String(chain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the outbound fee information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outboundFeeAsset: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('outboundFeeAsset', 'asset', asset)
            const localVarPath = `/thorchain/outbound_fee/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outboundFees: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/outbound_fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/ragnarok`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ban(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ban(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constants(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.constants(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboundAddresses(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InboundAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboundAddresses(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastblock(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastblock(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastblockChain(chain: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastblockChain(chain, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async network(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.network(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the outbound fee information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outboundFeeAsset(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutboundFeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outboundFeeAsset(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outboundFees(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutboundFeesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outboundFees(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragnarok(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragnarok(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async version(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.version(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban(address: string, height?: number, options?: any): AxiosPromise<BanResponse> {
            return localVarFp.ban(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants(height?: number, options?: any): AxiosPromise<ConstantsResponse> {
            return localVarFp.constants(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses(height?: number, options?: any): AxiosPromise<InboundAddressesResponse> {
            return localVarFp.inboundAddresses(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock(height?: number, options?: any): AxiosPromise<LastBlockResponse> {
            return localVarFp.lastblock(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain(chain: string, height?: number, options?: any): AxiosPromise<LastBlockResponse> {
            return localVarFp.lastblockChain(chain, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network(height?: number, options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.network(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the outbound fee information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outboundFeeAsset(asset: string, height?: number, options?: any): AxiosPromise<OutboundFeesResponse> {
            return localVarFp.outboundFeeAsset(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outboundFees(height?: number, options?: any): AxiosPromise<OutboundFeesResponse> {
            return localVarFp.outboundFees(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok(height?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.ragnarok(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(height?: number, options?: any): AxiosPromise<VersionResponse> {
            return localVarFp.version(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * Returns the ban status for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public ban(address: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).ban(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns constant configuration, can be overridden by mimir.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public constants(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).constants(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the set of asgard addresses that should be used for inbound transactions.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public inboundAddresses(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).inboundAddresses(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for all chains.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public lastblock(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).lastblock(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for the provided chain.
     * @param {string} chain 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public lastblockChain(chain: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).lastblockChain(chain, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns network overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public network(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).network(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the outbound fee information for the provided asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public outboundFeeAsset(asset: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).outboundFeeAsset(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for all chains.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public outboundFees(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).outboundFees(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a boolean indicating whether the chain is in ragnarok.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public ragnarok(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).ragnarok(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the network\'s current THORNode version, the network\'s next THORNode version, and the querier\'s THORNode version.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public version(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).version(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('node', 'address', address)
            const localVarPath = `/thorchain/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async node(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.node(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodes(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodes(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node(address: string, height?: number, options?: any): AxiosPromise<Node> {
            return localVarFp.node(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes(height?: number, options?: any): AxiosPromise<NodesResponse> {
            return localVarFp.nodes(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * Returns node information for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public node(address: string, height?: number, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).node(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns node information for all registered validators.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public nodes(height?: number, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).nodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolSlipApi - axios parameter creator
 * @export
 */
export const PoolSlipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the pool slip information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolslip: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('poolslip', 'asset', asset)
            const localVarPath = `/thorchain/slip/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the pool slip information for all Available Layer 1 pool assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolslips: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/slips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolSlipApi - functional programming interface
 * @export
 */
export const PoolSlipApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolSlipApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the pool slip information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolslip(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolSlipResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.poolslip(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the pool slip information for all Available Layer 1 pool assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolslips(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolSlipResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.poolslips(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolSlipApi - factory interface
 * @export
 */
export const PoolSlipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolSlipApiFp(configuration)
    return {
        /**
         * Returns the pool slip information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolslip(asset: string, height?: number, options?: any): AxiosPromise<PoolSlipResponse> {
            return localVarFp.poolslip(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool slip information for all Available Layer 1 pool assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolslips(height?: number, options?: any): AxiosPromise<PoolSlipResponse> {
            return localVarFp.poolslips(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolSlipApi - object-oriented interface
 * @export
 * @class PoolSlipApi
 * @extends {BaseAPI}
 */
export class PoolSlipApi extends BaseAPI {
    /**
     * Returns the pool slip information for the provided asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolSlipApi
     */
    public poolslip(asset: string, height?: number, options?: AxiosRequestConfig) {
        return PoolSlipApiFp(this.configuration).poolslip(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the pool slip information for all Available Layer 1 pool assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolSlipApi
     */
    public poolslips(height?: number, options?: AxiosRequestConfig) {
        return PoolSlipApiFp(this.configuration).poolslips(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the pool information for the provided derived asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpool: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('dpool', 'asset', asset)
            const localVarPath = `/thorchain/dpool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the pool information for all derived assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpools: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/dpools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pool', 'asset', asset)
            const localVarPath = `/thorchain/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the pool information for the provided derived asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpool(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DerivedPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpool(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the pool information for all derived assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dpools(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DerivedPoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dpools(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pool(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pools(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pools(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * Returns the pool information for the provided derived asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpool(asset: string, height?: number, options?: any): AxiosPromise<DerivedPool> {
            return localVarFp.dpool(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool information for all derived assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dpools(height?: number, options?: any): AxiosPromise<DerivedPoolsResponse> {
            return localVarFp.dpools(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(asset: string, height?: number, options?: any): AxiosPromise<Pool> {
            return localVarFp.pool(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools(height?: number, options?: any): AxiosPromise<PoolsResponse> {
            return localVarFp.pools(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * Returns the pool information for the provided derived asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public dpool(asset: string, height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).dpool(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the pool information for all derived assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public dpools(height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).dpools(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the pool information for the provided asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public pool(asset: string, height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).pool(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the pool information for all assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public pools(height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).pools(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueueApi - axios parameter creator
 * @export
 */
export const QueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue/outbound`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue/scheduled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the swap queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueSwap: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/queue/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueueApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queue(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queue(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueOutbound(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutboundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueOutbound(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueScheduled(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueScheduled(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the swap queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueSwap(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwapQueueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueSwap(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueueApiFp(configuration)
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue(height?: number, options?: any): AxiosPromise<QueueResponse> {
            return localVarFp.queue(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound(height?: number, options?: any): AxiosPromise<OutboundResponse> {
            return localVarFp.queueOutbound(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled(height?: number, options?: any): AxiosPromise<ScheduledResponse> {
            return localVarFp.queueScheduled(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the swap queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueSwap(height?: number, options?: any): AxiosPromise<SwapQueueResponse> {
            return localVarFp.queueSwap(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI {
    /**
     * Returns queue statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queue(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queue(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the outbound queue including estimated RUNE values.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueOutbound(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueOutbound(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the scheduled queue.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueScheduled(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueScheduled(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the swap queue.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueSwap(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueSwap(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuoteApi - axios parameter creator
 * @export
 */
export const QuoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide a quote estimate for the provided loan close.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the asset used to repay the loan
         * @param {number} [repayBps] the basis points of the existing position to repay
         * @param {string} [toAsset] the collateral asset of the loan
         * @param {string} [loanOwner] the owner of the loan collateral
         * @param {string} [minOut] the minimum amount of the target asset to accept
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteloanclose: async (height?: number, fromAsset?: string, repayBps?: number, toAsset?: string, loanOwner?: string, minOut?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/quote/loan/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromAsset !== undefined) {
                localVarQueryParameter['from_asset'] = fromAsset;
            }

            if (repayBps !== undefined) {
                localVarQueryParameter['repay_bps'] = repayBps;
            }

            if (toAsset !== undefined) {
                localVarQueryParameter['to_asset'] = toAsset;
            }

            if (loanOwner !== undefined) {
                localVarQueryParameter['loan_owner'] = loanOwner;
            }

            if (minOut !== undefined) {
                localVarQueryParameter['min_out'] = minOut;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a quote estimate for the provided loan open.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the collateral asset
         * @param {number} [amount] the collateral asset amount in 1e8 decimals
         * @param {string} [toAsset] the target asset to receive (loan denominated in TOR regardless)
         * @param {string} [destination] the destination address, required to generate memo
         * @param {string} [minOut] the minimum amount of the target asset to accept
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or thorname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteloanopen: async (height?: number, fromAsset?: string, amount?: number, toAsset?: string, destination?: string, minOut?: string, affiliateBps?: number, affiliate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/quote/loan/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromAsset !== undefined) {
                localVarQueryParameter['from_asset'] = fromAsset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (toAsset !== undefined) {
                localVarQueryParameter['to_asset'] = toAsset;
            }

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (minOut !== undefined) {
                localVarQueryParameter['min_out'] = minOut;
            }

            if (affiliateBps !== undefined) {
                localVarQueryParameter['affiliate_bps'] = affiliateBps;
            }

            if (affiliate !== undefined) {
                localVarQueryParameter['affiliate'] = affiliate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a quote estimate for the provided saver deposit.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to deposit
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverdeposit: async (height?: number, asset?: string, amount?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/quote/saver/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a quote estimate for the provided saver withdraw.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to withdraw
         * @param {string} [address] the address for the position
         * @param {number} [withdrawBps] the basis points of the existing position to withdraw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverwithdraw: async (height?: number, asset?: string, address?: string, withdrawBps?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/quote/saver/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (withdrawBps !== undefined) {
                localVarQueryParameter['withdraw_bps'] = withdrawBps;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a quote estimate for the provided swap.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the source asset
         * @param {string} [toAsset] the target asset
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {string} [destination] the destination address, required to generate memo
         * @param {string} [refundAddress] the refund address, refunds will be sent here if the swap fails
         * @param {number} [streamingInterval] the interval in which streaming swaps are swapped
         * @param {number} [streamingQuantity] the quantity of swaps within a streaming swap
         * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or thorname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteswap: async (height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, refundAddress?: string, streamingInterval?: number, streamingQuantity?: number, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/quote/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromAsset !== undefined) {
                localVarQueryParameter['from_asset'] = fromAsset;
            }

            if (toAsset !== undefined) {
                localVarQueryParameter['to_asset'] = toAsset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (refundAddress !== undefined) {
                localVarQueryParameter['refund_address'] = refundAddress;
            }

            if (streamingInterval !== undefined) {
                localVarQueryParameter['streaming_interval'] = streamingInterval;
            }

            if (streamingQuantity !== undefined) {
                localVarQueryParameter['streaming_quantity'] = streamingQuantity;
            }

            if (toleranceBps !== undefined) {
                localVarQueryParameter['tolerance_bps'] = toleranceBps;
            }

            if (affiliateBps !== undefined) {
                localVarQueryParameter['affiliate_bps'] = affiliateBps;
            }

            if (affiliate !== undefined) {
                localVarQueryParameter['affiliate'] = affiliate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteApi - functional programming interface
 * @export
 */
export const QuoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Provide a quote estimate for the provided loan close.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the asset used to repay the loan
         * @param {number} [repayBps] the basis points of the existing position to repay
         * @param {string} [toAsset] the collateral asset of the loan
         * @param {string} [loanOwner] the owner of the loan collateral
         * @param {string} [minOut] the minimum amount of the target asset to accept
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteloanclose(height?: number, fromAsset?: string, repayBps?: number, toAsset?: string, loanOwner?: string, minOut?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteLoanCloseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteloanclose(height, fromAsset, repayBps, toAsset, loanOwner, minOut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a quote estimate for the provided loan open.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the collateral asset
         * @param {number} [amount] the collateral asset amount in 1e8 decimals
         * @param {string} [toAsset] the target asset to receive (loan denominated in TOR regardless)
         * @param {string} [destination] the destination address, required to generate memo
         * @param {string} [minOut] the minimum amount of the target asset to accept
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or thorname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteloanopen(height?: number, fromAsset?: string, amount?: number, toAsset?: string, destination?: string, minOut?: string, affiliateBps?: number, affiliate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteLoanOpenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteloanopen(height, fromAsset, amount, toAsset, destination, minOut, affiliateBps, affiliate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a quote estimate for the provided saver deposit.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to deposit
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesaverdeposit(height?: number, asset?: string, amount?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteSaverDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesaverdeposit(height, asset, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a quote estimate for the provided saver withdraw.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to withdraw
         * @param {string} [address] the address for the position
         * @param {number} [withdrawBps] the basis points of the existing position to withdraw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesaverwithdraw(height?: number, asset?: string, address?: string, withdrawBps?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteSaverWithdrawResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesaverwithdraw(height, asset, address, withdrawBps, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a quote estimate for the provided swap.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the source asset
         * @param {string} [toAsset] the target asset
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {string} [destination] the destination address, required to generate memo
         * @param {string} [refundAddress] the refund address, refunds will be sent here if the swap fails
         * @param {number} [streamingInterval] the interval in which streaming swaps are swapped
         * @param {number} [streamingQuantity] the quantity of swaps within a streaming swap
         * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or thorname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteswap(height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, refundAddress?: string, streamingInterval?: number, streamingQuantity?: number, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteSwapResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteswap(height, fromAsset, toAsset, amount, destination, refundAddress, streamingInterval, streamingQuantity, toleranceBps, affiliateBps, affiliate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuoteApi - factory interface
 * @export
 */
export const QuoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuoteApiFp(configuration)
    return {
        /**
         * Provide a quote estimate for the provided loan close.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the asset used to repay the loan
         * @param {number} [repayBps] the basis points of the existing position to repay
         * @param {string} [toAsset] the collateral asset of the loan
         * @param {string} [loanOwner] the owner of the loan collateral
         * @param {string} [minOut] the minimum amount of the target asset to accept
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteloanclose(height?: number, fromAsset?: string, repayBps?: number, toAsset?: string, loanOwner?: string, minOut?: string, options?: any): AxiosPromise<QuoteLoanCloseResponse> {
            return localVarFp.quoteloanclose(height, fromAsset, repayBps, toAsset, loanOwner, minOut, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a quote estimate for the provided loan open.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the collateral asset
         * @param {number} [amount] the collateral asset amount in 1e8 decimals
         * @param {string} [toAsset] the target asset to receive (loan denominated in TOR regardless)
         * @param {string} [destination] the destination address, required to generate memo
         * @param {string} [minOut] the minimum amount of the target asset to accept
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or thorname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteloanopen(height?: number, fromAsset?: string, amount?: number, toAsset?: string, destination?: string, minOut?: string, affiliateBps?: number, affiliate?: string, options?: any): AxiosPromise<QuoteLoanOpenResponse> {
            return localVarFp.quoteloanopen(height, fromAsset, amount, toAsset, destination, minOut, affiliateBps, affiliate, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a quote estimate for the provided saver deposit.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to deposit
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverdeposit(height?: number, asset?: string, amount?: number, options?: any): AxiosPromise<QuoteSaverDepositResponse> {
            return localVarFp.quotesaverdeposit(height, asset, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a quote estimate for the provided saver withdraw.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to withdraw
         * @param {string} [address] the address for the position
         * @param {number} [withdrawBps] the basis points of the existing position to withdraw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverwithdraw(height?: number, asset?: string, address?: string, withdrawBps?: number, options?: any): AxiosPromise<QuoteSaverWithdrawResponse> {
            return localVarFp.quotesaverwithdraw(height, asset, address, withdrawBps, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a quote estimate for the provided swap.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the source asset
         * @param {string} [toAsset] the target asset
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {string} [destination] the destination address, required to generate memo
         * @param {string} [refundAddress] the refund address, refunds will be sent here if the swap fails
         * @param {number} [streamingInterval] the interval in which streaming swaps are swapped
         * @param {number} [streamingQuantity] the quantity of swaps within a streaming swap
         * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or thorname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteswap(height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, refundAddress?: string, streamingInterval?: number, streamingQuantity?: number, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options?: any): AxiosPromise<QuoteSwapResponse> {
            return localVarFp.quoteswap(height, fromAsset, toAsset, amount, destination, refundAddress, streamingInterval, streamingQuantity, toleranceBps, affiliateBps, affiliate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuoteApi - object-oriented interface
 * @export
 * @class QuoteApi
 * @extends {BaseAPI}
 */
export class QuoteApi extends BaseAPI {
    /**
     * Provide a quote estimate for the provided loan close.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [fromAsset] the asset used to repay the loan
     * @param {number} [repayBps] the basis points of the existing position to repay
     * @param {string} [toAsset] the collateral asset of the loan
     * @param {string} [loanOwner] the owner of the loan collateral
     * @param {string} [minOut] the minimum amount of the target asset to accept
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quoteloanclose(height?: number, fromAsset?: string, repayBps?: number, toAsset?: string, loanOwner?: string, minOut?: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quoteloanclose(height, fromAsset, repayBps, toAsset, loanOwner, minOut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a quote estimate for the provided loan open.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [fromAsset] the collateral asset
     * @param {number} [amount] the collateral asset amount in 1e8 decimals
     * @param {string} [toAsset] the target asset to receive (loan denominated in TOR regardless)
     * @param {string} [destination] the destination address, required to generate memo
     * @param {string} [minOut] the minimum amount of the target asset to accept
     * @param {number} [affiliateBps] the affiliate fee in basis points
     * @param {string} [affiliate] the affiliate (address or thorname)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quoteloanopen(height?: number, fromAsset?: string, amount?: number, toAsset?: string, destination?: string, minOut?: string, affiliateBps?: number, affiliate?: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quoteloanopen(height, fromAsset, amount, toAsset, destination, minOut, affiliateBps, affiliate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a quote estimate for the provided saver deposit.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [asset] the asset to deposit
     * @param {number} [amount] the source asset amount in 1e8 decimals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesaverdeposit(height?: number, asset?: string, amount?: number, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesaverdeposit(height, asset, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a quote estimate for the provided saver withdraw.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [asset] the asset to withdraw
     * @param {string} [address] the address for the position
     * @param {number} [withdrawBps] the basis points of the existing position to withdraw
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesaverwithdraw(height?: number, asset?: string, address?: string, withdrawBps?: number, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesaverwithdraw(height, asset, address, withdrawBps, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a quote estimate for the provided swap.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [fromAsset] the source asset
     * @param {string} [toAsset] the target asset
     * @param {number} [amount] the source asset amount in 1e8 decimals
     * @param {string} [destination] the destination address, required to generate memo
     * @param {string} [refundAddress] the refund address, refunds will be sent here if the swap fails
     * @param {number} [streamingInterval] the interval in which streaming swaps are swapped
     * @param {number} [streamingQuantity] the quantity of swaps within a streaming swap
     * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
     * @param {number} [affiliateBps] the affiliate fee in basis points
     * @param {string} [affiliate] the affiliate (address or thorname)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quoteswap(height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, refundAddress?: string, streamingInterval?: number, streamingQuantity?: number, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quoteswap(height, fromAsset, toAsset, amount, destination, refundAddress, streamingInterval, streamingQuantity, toleranceBps, affiliateBps, affiliate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RUNEPoolApi - axios parameter creator
 * @export
 */
export const RUNEPoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the pool information for the RUNE pool.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runePool: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/runepool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the RUNE Provider information for an address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runeProvider: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('runeProvider', 'address', address)
            const localVarPath = `/thorchain/rune_provider/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all RUNE Providers.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runeProviders: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/rune_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RUNEPoolApi - functional programming interface
 * @export
 */
export const RUNEPoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RUNEPoolApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the pool information for the RUNE pool.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runePool(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RUNEPoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runePool(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the RUNE Provider information for an address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runeProvider(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RUNEProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runeProvider(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all RUNE Providers.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runeProviders(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RUNEProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runeProviders(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RUNEPoolApi - factory interface
 * @export
 */
export const RUNEPoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RUNEPoolApiFp(configuration)
    return {
        /**
         * Returns the pool information for the RUNE pool.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runePool(height?: number, options?: any): AxiosPromise<RUNEPoolResponse> {
            return localVarFp.runePool(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the RUNE Provider information for an address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runeProvider(address: string, height?: number, options?: any): AxiosPromise<RUNEProvider> {
            return localVarFp.runeProvider(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all RUNE Providers.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runeProviders(height?: number, options?: any): AxiosPromise<RUNEProvidersResponse> {
            return localVarFp.runeProviders(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RUNEPoolApi - object-oriented interface
 * @export
 * @class RUNEPoolApi
 * @extends {BaseAPI}
 */
export class RUNEPoolApi extends BaseAPI {
    /**
     * Returns the pool information for the RUNE pool.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RUNEPoolApi
     */
    public runePool(height?: number, options?: AxiosRequestConfig) {
        return RUNEPoolApiFp(this.configuration).runePool(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the RUNE Provider information for an address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RUNEPoolApi
     */
    public runeProvider(address: string, height?: number, options?: AxiosRequestConfig) {
        return RUNEPoolApiFp(this.configuration).runeProvider(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all RUNE Providers.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RUNEPoolApi
     */
    public runeProviders(height?: number, options?: AxiosRequestConfig) {
        return RUNEPoolApiFp(this.configuration).runeProviders(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SaversApi - axios parameter creator
 * @export
 */
export const SaversApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the saver position given then savers pool and address.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saver: async (asset: string, address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('saver', 'asset', asset)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('saver', 'address', address)
            const localVarPath = `/thorchain/pool/{asset}/saver/{address}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all savers for the savers pool.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savers: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('savers', 'asset', asset)
            const localVarPath = `/thorchain/pool/{asset}/savers`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SaversApi - functional programming interface
 * @export
 */
export const SaversApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SaversApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the saver position given then savers pool and address.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saver(asset: string, address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Saver>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saver(asset, address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all savers for the savers pool.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savers(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savers(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SaversApi - factory interface
 * @export
 */
export const SaversApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SaversApiFp(configuration)
    return {
        /**
         * Returns the saver position given then savers pool and address.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saver(asset: string, address: string, height?: number, options?: any): AxiosPromise<Saver> {
            return localVarFp.saver(asset, address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all savers for the savers pool.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savers(asset: string, height?: number, options?: any): AxiosPromise<SaversResponse> {
            return localVarFp.savers(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SaversApi - object-oriented interface
 * @export
 * @class SaversApi
 * @extends {BaseAPI}
 */
export class SaversApi extends BaseAPI {
    /**
     * Returns the saver position given then savers pool and address.
     * @param {string} asset 
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaversApi
     */
    public saver(asset: string, address: string, height?: number, options?: AxiosRequestConfig) {
        return SaversApiFp(this.configuration).saver(asset, address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all savers for the savers pool.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaversApi
     */
    public savers(asset: string, height?: number, options?: AxiosRequestConfig) {
        return SaversApiFp(this.configuration).savers(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StreamingSwapApi - axios parameter creator
 * @export
 */
export const StreamingSwapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the state of a streaming swap
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSwap: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('streamSwap', 'hash', hash)
            const localVarPath = `/thorchain/swap/streaming/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the state of all streaming swaps
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSwaps: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/swaps/streaming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamingSwapApi - functional programming interface
 * @export
 */
export const StreamingSwapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamingSwapApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the state of a streaming swap
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSwap(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingSwap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSwap(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the state of all streaming swaps
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSwaps(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingSwapsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSwaps(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StreamingSwapApi - factory interface
 * @export
 */
export const StreamingSwapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamingSwapApiFp(configuration)
    return {
        /**
         * Returns the state of a streaming swap
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSwap(hash: string, height?: number, options?: any): AxiosPromise<StreamingSwap> {
            return localVarFp.streamSwap(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the state of all streaming swaps
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSwaps(height?: number, options?: any): AxiosPromise<StreamingSwapsResponse> {
            return localVarFp.streamSwaps(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamingSwapApi - object-oriented interface
 * @export
 * @class StreamingSwapApi
 * @extends {BaseAPI}
 */
export class StreamingSwapApi extends BaseAPI {
    /**
     * Returns the state of a streaming swap
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamingSwapApi
     */
    public streamSwap(hash: string, height?: number, options?: AxiosRequestConfig) {
        return StreamingSwapApiFp(this.configuration).streamSwap(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the state of all streaming swaps
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamingSwapApi
     */
    public streamSwaps(height?: number, options?: AxiosRequestConfig) {
        return StreamingSwapApiFp(this.configuration).streamSwaps(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TSSApi - axios parameter creator
 * @export
 */
export const TSSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns keygen information for the provided height and pubkey - the pubkey being of one of the members of a keygen block for that height
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keygenPubkey: async (height: number, pubkey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keygenPubkey', 'height', height)
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('keygenPubkey', 'pubkey', pubkey)
            const localVarPath = `/thorchain/keygen/{height}/{pubkey}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysign', 'height', height)
            const localVarPath = `/thorchain/keysign/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey: async (height: number, pubkey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysignPubkey', 'height', height)
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('keysignPubkey', 'pubkey', pubkey)
            const localVarPath = `/thorchain/keysign/{height}/{pubkey}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen: async (pubkey: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('metricsKeygen', 'pubkey', pubkey)
            const localVarPath = `/thorchain/metric/keygen/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TSSApi - functional programming interface
 * @export
 */
export const TSSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TSSApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns keygen information for the provided height and pubkey - the pubkey being of one of the members of a keygen block for that height
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keygenPubkey(height: number, pubkey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeygenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keygenPubkey(height, pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysign(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysign(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysignPubkey(height: number, pubkey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysignPubkey(height, pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsKeygen(pubkey: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeygenMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsKeygen(pubkey, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TSSApi - factory interface
 * @export
 */
export const TSSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TSSApiFp(configuration)
    return {
        /**
         * Returns keygen information for the provided height and pubkey - the pubkey being of one of the members of a keygen block for that height
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keygenPubkey(height: number, pubkey: string, options?: any): AxiosPromise<KeygenResponse> {
            return localVarFp.keygenPubkey(height, pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign(height: number, options?: any): AxiosPromise<KeysignResponse> {
            return localVarFp.keysign(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey(height: number, pubkey: string, options?: any): AxiosPromise<KeysignResponse> {
            return localVarFp.keysignPubkey(height, pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(height?: number, options?: any): AxiosPromise<MetricsResponse> {
            return localVarFp.metrics(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen(pubkey: string, height?: number, options?: any): AxiosPromise<KeygenMetricsResponse> {
            return localVarFp.metricsKeygen(pubkey, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TSSApi - object-oriented interface
 * @export
 * @class TSSApi
 * @extends {BaseAPI}
 */
export class TSSApi extends BaseAPI {
    /**
     * Returns keygen information for the provided height and pubkey - the pubkey being of one of the members of a keygen block for that height
     * @param {number} height 
     * @param {string} pubkey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keygenPubkey(height: number, pubkey: string, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keygenPubkey(height, pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
     * @param {number} height 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keysign(height: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keysign(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
     * @param {number} height 
     * @param {string} pubkey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keysignPubkey(height: number, pubkey: string, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keysignPubkey(height, pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keygen and keysign metrics for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public metrics(height?: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).metrics(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keygen metrics for the provided vault pubkey.
     * @param {string} pubkey 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public metricsKeygen(pubkey: string, height?: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).metricsKeygen(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThornamesApi - axios parameter creator
 * @export
 */
export const ThornamesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname: async (name: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('thorname', 'name', name)
            const localVarPath = `/thorchain/thorname/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThornamesApi - functional programming interface
 * @export
 */
export const ThornamesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThornamesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thorname(name: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Thorname>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thorname(name, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThornamesApi - factory interface
 * @export
 */
export const ThornamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThornamesApiFp(configuration)
    return {
        /**
         * Returns addresses registered to the provided thorname.
         * @param {string} name the thornode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorname(name: string, height?: number, options?: any): AxiosPromise<Thorname> {
            return localVarFp.thorname(name, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThornamesApi - object-oriented interface
 * @export
 * @class ThornamesApi
 * @extends {BaseAPI}
 */
export class ThornamesApi extends BaseAPI {
    /**
     * Returns addresses registered to the provided thorname.
     * @param {string} name the thornode to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThornamesApi
     */
    public thorname(name: string, height?: number, options?: AxiosRequestConfig) {
        return ThornamesApiFp(this.configuration).thorname(name, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeAccountApi - axios parameter creator
 * @export
 */
export const TradeAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the units and depth of a trade account
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeAccount: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('tradeAccount', 'address', address)
            const localVarPath = `/thorchain/trade/account/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeAccountApi - functional programming interface
 * @export
 */
export const TradeAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the units and depth of a trade account
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeAccount(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeAccount(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradeAccountApi - factory interface
 * @export
 */
export const TradeAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeAccountApiFp(configuration)
    return {
        /**
         * Returns the units and depth of a trade account
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeAccount(address: string, height?: number, options?: any): AxiosPromise<TradeAccountResponse> {
            return localVarFp.tradeAccount(address, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeAccountApi - object-oriented interface
 * @export
 * @class TradeAccountApi
 * @extends {BaseAPI}
 */
export class TradeAccountApi extends BaseAPI {
    /**
     * Returns the units and depth of a trade account
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeAccountApi
     */
    public tradeAccount(address: string, height?: number, options?: AxiosRequestConfig) {
        return TradeAccountApiFp(this.configuration).tradeAccount(address, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeAccountsApi - axios parameter creator
 * @export
 */
export const TradeAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all trade accounts for an asset
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeAccounts: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('tradeAccounts', 'asset', asset)
            const localVarPath = `/thorchain/trade/accounts/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeAccountsApi - functional programming interface
 * @export
 */
export const TradeAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all trade accounts for an asset
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeAccounts(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeAccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeAccounts(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradeAccountsApi - factory interface
 * @export
 */
export const TradeAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeAccountsApiFp(configuration)
    return {
        /**
         * Returns all trade accounts for an asset
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeAccounts(asset: string, height?: number, options?: any): AxiosPromise<TradeAccountsResponse> {
            return localVarFp.tradeAccounts(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeAccountsApi - object-oriented interface
 * @export
 * @class TradeAccountsApi
 * @extends {BaseAPI}
 */
export class TradeAccountsApi extends BaseAPI {
    /**
     * Returns all trade accounts for an asset
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeAccountsApi
     */
    public tradeAccounts(asset: string, height?: number, options?: AxiosRequestConfig) {
        return TradeAccountsApiFp(this.configuration).tradeAccounts(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeUnitApi - axios parameter creator
 * @export
 */
export const TradeUnitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the total units and depth of a trade asset
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeUnit: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('tradeUnit', 'asset', asset)
            const localVarPath = `/thorchain/trade/unit/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeUnitApi - functional programming interface
 * @export
 */
export const TradeUnitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeUnitApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the total units and depth of a trade asset
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeUnit(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeUnitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeUnit(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradeUnitApi - factory interface
 * @export
 */
export const TradeUnitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeUnitApiFp(configuration)
    return {
        /**
         * Returns the total units and depth of a trade asset
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeUnit(asset: string, height?: number, options?: any): AxiosPromise<TradeUnitResponse> {
            return localVarFp.tradeUnit(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeUnitApi - object-oriented interface
 * @export
 * @class TradeUnitApi
 * @extends {BaseAPI}
 */
export class TradeUnitApi extends BaseAPI {
    /**
     * Returns the total units and depth of a trade asset
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeUnitApi
     */
    public tradeUnit(asset: string, height?: number, options?: AxiosRequestConfig) {
        return TradeUnitApiFp(this.configuration).tradeUnit(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradeUnitsApi - axios parameter creator
 * @export
 */
export const TradeUnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the total units and depth for each trade asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeUnits: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/trade/units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeUnitsApi - functional programming interface
 * @export
 */
export const TradeUnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeUnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the total units and depth for each trade asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeUnits(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeUnitsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeUnits(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradeUnitsApi - factory interface
 * @export
 */
export const TradeUnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeUnitsApiFp(configuration)
    return {
        /**
         * Returns the total units and depth for each trade asset
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeUnits(height?: number, options?: any): AxiosPromise<TradeUnitsResponse> {
            return localVarFp.tradeUnits(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeUnitsApi - object-oriented interface
 * @export
 * @class TradeUnitsApi
 * @extends {BaseAPI}
 */
export class TradeUnitsApi extends BaseAPI {
    /**
     * Returns the total units and depth for each trade asset
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeUnitsApi
     */
    public tradeUnits(height?: number, options?: AxiosRequestConfig) {
        return TradeUnitsApiFp(this.configuration).tradeUnits(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('tx', 'hash', hash)
            const localVarPath = `/thorchain/tx/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txSigners', 'hash', hash)
            const localVarPath = `/thorchain/tx/details/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated - migrate to /thorchain/tx/details.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSignersOld: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txSignersOld', 'hash', hash)
            const localVarPath = `/thorchain/tx/{hash}/signers`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the processing stages of a provided inbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txStages: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txStages', 'hash', hash)
            const localVarPath = `/thorchain/tx/stages/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the status of a provided inbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txStatus: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txStatus', 'hash', hash)
            const localVarPath = `/thorchain/tx/status/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tx(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tx(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txSigners(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txSigners(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deprecated - migrate to /thorchain/tx/details.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txSignersOld(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxSignersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txSignersOld(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the processing stages of a provided inbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txStages(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxStagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txStages(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the status of a provided inbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txStatus(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txStatus(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx(hash: string, height?: number, options?: any): AxiosPromise<TxResponse> {
            return localVarFp.tx(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners(hash: string, height?: number, options?: any): AxiosPromise<TxDetailsResponse> {
            return localVarFp.txSigners(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecated - migrate to /thorchain/tx/details.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSignersOld(hash: string, height?: number, options?: any): AxiosPromise<TxSignersResponse> {
            return localVarFp.txSignersOld(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the processing stages of a provided inbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txStages(hash: string, height?: number, options?: any): AxiosPromise<TxStagesResponse> {
            return localVarFp.txStages(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the status of a provided inbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txStatus(hash: string, height?: number, options?: any): AxiosPromise<TxStatusResponse> {
            return localVarFp.txStatus(hash, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Returns the observed transaction for a provided inbound or outbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public tx(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).tx(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the signers for a provided inbound or outbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txSigners(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).txSigners(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecated - migrate to /thorchain/tx/details.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txSignersOld(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).txSignersOld(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the processing stages of a provided inbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txStages(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).txStages(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the status of a provided inbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txStatus(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).txStatus(hash, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VaultsApi - axios parameter creator
 * @export
 */
export const VaultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/vaults/asgard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault: async (pubkey: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('vault', 'pubkey', pubkey)
            const localVarPath = `/thorchain/vault/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/vaults/pubkeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/thorchain/vaults/yggdrasil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VaultsApi - functional programming interface
 * @export
 */
export const VaultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VaultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asgard(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asgard(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vault(pubkey: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vault(pubkey, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vaultPubkeys(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultPubkeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vaultPubkeys(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async yggdrasil(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YggdrasilVaultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.yggdrasil(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VaultsApi - factory interface
 * @export
 */
export const VaultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VaultsApiFp(configuration)
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard(height?: number, options?: any): AxiosPromise<VaultsResponse> {
            return localVarFp.asgard(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault(pubkey: string, height?: number, options?: any): AxiosPromise<Vault> {
            return localVarFp.vault(pubkey, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys(height?: number, options?: any): AxiosPromise<VaultPubkeysResponse> {
            return localVarFp.vaultPubkeys(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil(height?: number, options?: any): AxiosPromise<YggdrasilVaultsResponse> {
            return localVarFp.yggdrasil(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
export class VaultsApi extends BaseAPI {
    /**
     * Returns current asgard vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public asgard(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).asgard(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the vault for the provided pubkey.
     * @param {string} pubkey 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public vault(pubkey: string, height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).vault(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all pubkeys for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public vaultPubkeys(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).vaultPubkeys(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current yggdrasil vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public yggdrasil(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).yggdrasil(height, options).then((request) => request(this.axios, this.basePath));
    }
}


