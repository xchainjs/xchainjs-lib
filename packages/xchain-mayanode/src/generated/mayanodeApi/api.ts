/* tslint:disable */
/* eslint-disable */
/**
 * Mayanode API
 * Mayanode REST API.
 *
 * The version of the OpenAPI document: 1.106.1
 * Contact: devs@mayachain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BanResponse
 */
export interface BanResponse {
    /**
     * 
     * @type {string}
     * @memberof BanResponse
     */
    'node_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof BanResponse
     */
    'block_height'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BanResponse
     */
    'signers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Bucket
 */
export interface Bucket {
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    'balance_asset': string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    'asset': string;
    /**
     * the total pool liquidity provider units
     * @type {string}
     * @memberof Bucket
     */
    'LP_units': string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface BucketsResponse
 */
export interface BucketsResponse extends Array<Bucket> {
}
/**
 * 
 * @export
 * @interface ChainHeight
 */
export interface ChainHeight {
    /**
     * 
     * @type {string}
     * @memberof ChainHeight
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof ChainHeight
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    'amount': string;
    /**
     * 
     * @type {number}
     * @memberof Coin
     */
    'decimals'?: number;
}
/**
 * 
 * @export
 * @interface ConstantsResponse
 */
export interface ConstantsResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'int_64_values'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'bool_values'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ConstantsResponse
     */
    'string_values'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface InboundAddress
 */
export interface InboundAddress {
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'pub_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof InboundAddress
     */
    'router'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InboundAddress
     */
    'halted': boolean;
    /**
     * Returns true if trading is paused globally
     * @type {boolean}
     * @memberof InboundAddress
     */
    'global_trading_paused'?: boolean;
    /**
     * Returns true if trading is paused for this chain
     * @type {boolean}
     * @memberof InboundAddress
     */
    'chain_trading_paused'?: boolean;
    /**
     * Returns true if LP actions are paused for this chain
     * @type {boolean}
     * @memberof InboundAddress
     */
    'chain_lp_actions_paused'?: boolean;
    /**
     * The minimum fee rate used by vaults to send outbound TXs. The actual fee rate may be higher. For EVM chains this is returned in gwei (1e9).
     * @type {string}
     * @memberof InboundAddress
     */
    'gas_rate'?: string;
    /**
     * Units of the gas_rate.
     * @type {string}
     * @memberof InboundAddress
     */
    'gas_rate_units'?: string;
    /**
     * Avg size of outbound TXs on each chain. For UTXO chains it may be larger than average, as it takes into account vault consolidation txs, which can have many vouts
     * @type {string}
     * @memberof InboundAddress
     */
    'outbound_tx_size'?: string;
    /**
     * The total outbound fee charged to the user for outbound txs in the gas asset of the chain.
     * @type {string}
     * @memberof InboundAddress
     */
    'outbound_fee'?: string;
}
/**
 * 
 * @export
 * @interface InboundAddressesResponse
 */
export interface InboundAddressesResponse extends Array<InboundAddress> {
}
/**
 * 
 * @export
 * @interface KeygenMetric
 */
export interface KeygenMetric {
    /**
     * 
     * @type {string}
     * @memberof KeygenMetric
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<NodeKeygenMetric>}
     * @memberof KeygenMetric
     */
    'node_tss_times': Array<NodeKeygenMetric>;
}
/**
 * 
 * @export
 * @interface KeygenMetric1
 */
export interface KeygenMetric1 {
    /**
     * 
     * @type {string}
     * @memberof KeygenMetric1
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<NodeKeygenMetric>}
     * @memberof KeygenMetric1
     */
    'node_tss_times': Array<NodeKeygenMetric>;
}
/**
 * 
 * @export
 * @interface KeygenMetricsResponse
 */
export interface KeygenMetricsResponse extends Array<KeygenMetric1> {
}
/**
 * 
 * @export
 * @interface KeysignInfo
 */
export interface KeysignInfo {
    /**
     * the block(s) in which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue
     * @type {number}
     * @memberof KeysignInfo
     */
    'height'?: number;
    /**
     * 
     * @type {Array<TxOutItem>}
     * @memberof KeysignInfo
     */
    'tx_array': Array<TxOutItem>;
}
/**
 * 
 * @export
 * @interface KeysignMetrics
 */
export interface KeysignMetrics {
    /**
     * 
     * @type {string}
     * @memberof KeysignMetrics
     */
    'tx_id'?: string;
    /**
     * 
     * @type {Array<TssMetric>}
     * @memberof KeysignMetrics
     */
    'node_tss_times'?: Array<TssMetric>;
}
/**
 * 
 * @export
 * @interface KeysignResponse
 */
export interface KeysignResponse {
    /**
     * 
     * @type {KeysignInfo}
     * @memberof KeysignResponse
     */
    'keysign'?: KeysignInfo;
    /**
     * 
     * @type {string}
     * @memberof KeysignResponse
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface LPBondedNode
 */
export interface LPBondedNode {
    /**
     * 
     * @type {string}
     * @memberof LPBondedNode
     */
    'node_address': string;
    /**
     * 
     * @type {string}
     * @memberof LPBondedNode
     */
    'units': string;
}
/**
 * 
 * @export
 * @interface LastBlock
 */
export interface LastBlock {
    /**
     * 
     * @type {string}
     * @memberof LastBlock
     */
    'chain': string;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'last_observed_in': number;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'last_signed_out': number;
    /**
     * 
     * @type {number}
     * @memberof LastBlock
     */
    'mayachain': number;
}
/**
 * 
 * @export
 * @interface LastBlockResponse
 */
export interface LastBlockResponse extends Array<LastBlock> {
}
/**
 * 
 * @export
 * @interface LiquidityProvider
 */
export interface LiquidityProvider {
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'cacao_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_add_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_withdraw_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'units': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_cacao': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_asset': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'pending_tx_Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'cacao_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'asset_deposit_value': string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     * @deprecated
     */
    'node_bond_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof LiquidityProvider
     */
    'withdraw_counter': string;
    /**
     * 
     * @type {number}
     * @memberof LiquidityProvider
     */
    'last_withdraw_counter_height'?: number;
    /**
     * 
     * @type {Array<LPBondedNode>}
     * @memberof LiquidityProvider
     */
    'bonded_nodes': Array<LPBondedNode>;
}
/**
 * 
 * @export
 * @interface LiquidityProviderResponse
 */
export interface LiquidityProviderResponse extends Array<LiquidityProvider> {
}
/**
 * 
 * @export
 * @interface Mayaname
 */
export interface Mayaname {
    /**
     * 
     * @type {string}
     * @memberof Mayaname
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Mayaname
     */
    'expire_block_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Mayaname
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mayaname
     */
    'preferred_asset': string;
    /**
     * 
     * @type {Array<MayanameAlias>}
     * @memberof Mayaname
     */
    'aliases': Array<MayanameAlias>;
}
/**
 * 
 * @export
 * @interface Mayaname1
 */
export interface Mayaname1 {
    /**
     * 
     * @type {string}
     * @memberof Mayaname1
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mayaname1
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mayaname1
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof Mayaname1
     */
    'expire_block_height'?: number;
}
/**
 * 
 * @export
 * @interface MayanameAlias
 */
export interface MayanameAlias {
    /**
     * 
     * @type {string}
     * @memberof MayanameAlias
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof MayanameAlias
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface MayanameResponse
 */
export interface MayanameResponse extends Array<Mayaname1> {
}
/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * 
     * @type {KeygenMetricsResponse}
     * @memberof MetricsResponse
     */
    'keygen'?: KeygenMetricsResponse;
    /**
     * 
     * @type {KeysignMetrics}
     * @memberof MetricsResponse
     */
    'keysign'?: KeysignMetrics;
}
/**
 * 
 * @export
 * @interface MimirNodesResponse
 */
export interface MimirNodesResponse {
    /**
     * 
     * @type {Array<MimirVote>}
     * @memberof MimirNodesResponse
     */
    'mimirs'?: Array<MimirVote>;
}
/**
 * 
 * @export
 * @interface MimirResponse
 */
export interface MimirResponse {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface MimirVote
 */
export interface MimirVote {
    /**
     * 
     * @type {string}
     * @memberof MimirVote
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof MimirVote
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof MimirVote
     */
    'signer'?: string;
}
/**
 * 
 * @export
 * @interface NetworkResponse
 */
export interface NetworkResponse {
    /**
     * total amount of cacao awarded to node operators
     * @type {string}
     * @memberof NetworkResponse
     */
    'bond_reward_rune': string;
    /**
     * total bonded cacao
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_bond_units': string;
    /**
     * total reserve cacao
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_reserve': string;
    /**
     * total asgard cacao
     * @type {string}
     * @memberof NetworkResponse
     */
    'total_asgard': string;
    /**
     * Sum of the gas the network has spent to send outbounds
     * @type {string}
     * @memberof NetworkResponse
     */
    'gas_spent_cacao': string;
    /**
     * Sum of the gas withheld from users to cover outbound gas
     * @type {string}
     * @memberof NetworkResponse
     */
    'gas_withheld_cacao': string;
    /**
     * Current outbound fee multiplier, in basis points
     * @type {string}
     * @memberof NetworkResponse
     */
    'outbound_fee_multiplier'?: string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'node_address': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'status': NodeStatusEnum;
    /**
     * 
     * @type {NodePubKeySet}
     * @memberof Node
     */
    'pub_key_set': NodePubKeySet;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'aztec_address': string;
    /**
     * the consensus pub key for the node
     * @type {string}
     * @memberof Node
     */
    'validator_cons_pub_key': string;
    /**
     * current node bond
     * @type {string}
     * @memberof Node
     */
    'bond': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'reward': string;
    /**
     * the block height at which the node became active
     * @type {number}
     * @memberof Node
     */
    'active_block_height': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'bond_address': string;
    /**
     * the block height of the current provided information for the node
     * @type {number}
     * @memberof Node
     */
    'status_since': number;
    /**
     * the set of vault public keys of which the node is a member
     * @type {Array<string>}
     * @memberof Node
     */
    'signer_membership': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Node
     */
    'requested_to_leave': boolean;
    /**
     * indicates whether the node has been forced to leave by the network, typically via ban
     * @type {boolean}
     * @memberof Node
     */
    'forced_to_leave': boolean;
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'leave_height': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'ip_address': string;
    /**
     * the currently set version of the node
     * @type {string}
     * @memberof Node
     */
    'version': string;
    /**
     * the accumlated slash points, reset at churn but excessive slash points may carry over
     * @type {number}
     * @memberof Node
     */
    'slash_points': number;
    /**
     * 
     * @type {NodeJail}
     * @memberof Node
     */
    'jail': NodeJail;
    /**
     * the last observed heights for all chain by the node
     * @type {Array<ChainHeight>}
     * @memberof Node
     */
    'observe_chains': Array<ChainHeight>;
    /**
     * 
     * @type {NodePreflightStatus}
     * @memberof Node
     */
    'preflight_status': NodePreflightStatus;
    /**
     * 
     * @type {NodeBondProviders}
     * @memberof Node
     */
    'bond_providers': NodeBondProviders;
}

export const NodeStatusEnum = {
    Active: 'Active',
    Whitelisted: 'Whitelisted',
    Standby: 'Standby',
    Disabled: 'Disabled'
} as const;

export type NodeStatusEnum = typeof NodeStatusEnum[keyof typeof NodeStatusEnum];

/**
 * 
 * @export
 * @interface NodeBondProvider
 */
export interface NodeBondProvider {
    /**
     * 
     * @type {string}
     * @memberof NodeBondProvider
     */
    'bond_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBondProvider
     */
    'bond'?: string;
}
/**
 * 
 * @export
 * @interface NodeBondProviders
 */
export interface NodeBondProviders {
    /**
     * 
     * @type {string}
     * @memberof NodeBondProviders
     */
    'node_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBondProviders
     */
    'node_operator_fee'?: string;
    /**
     * 
     * @type {NodeBondProvider}
     * @memberof NodeBondProviders
     */
    'providers'?: NodeBondProvider;
}
/**
 * 
 * @export
 * @interface NodeJail
 */
export interface NodeJail {
    /**
     * 
     * @type {string}
     * @memberof NodeJail
     */
    'node_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof NodeJail
     */
    'release_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeJail
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface NodeKeygenMetric
 */
export interface NodeKeygenMetric {
    /**
     * 
     * @type {string}
     * @memberof NodeKeygenMetric
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeKeygenMetric
     */
    'tss_time'?: string;
}
/**
 * 
 * @export
 * @interface NodePreflightStatus
 */
export interface NodePreflightStatus {
    /**
     * the next status of the node
     * @type {string}
     * @memberof NodePreflightStatus
     */
    'status': string;
    /**
     * the reason for the transition to the next status
     * @type {string}
     * @memberof NodePreflightStatus
     */
    'reason': string;
    /**
     * 
     * @type {number}
     * @memberof NodePreflightStatus
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface NodePubKeySet
 */
export interface NodePubKeySet {
    /**
     * 
     * @type {string}
     * @memberof NodePubKeySet
     */
    'secp256k1'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodePubKeySet
     */
    'ed25519'?: string;
}
/**
 * 
 * @export
 * @interface NodesResponse
 */
export interface NodesResponse extends Array<Node> {
}
/**
 * 
 * @export
 * @interface ObservedTx
 */
export interface ObservedTx {
    /**
     * 
     * @type {Tx}
     * @memberof ObservedTx
     */
    'tx': Tx;
    /**
     * 
     * @type {string}
     * @memberof ObservedTx
     */
    'status'?: ObservedTxStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservedTx
     */
    'out_hashes'?: Array<string>;
    /**
     * the block height of the observed transaction on the source chain, not provided if chain is MAYA
     * @type {number}
     * @memberof ObservedTx
     */
    'block_height'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObservedTx
     */
    'signers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ObservedTx
     */
    'observed_pub_key'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObservedTx
     */
    'keysign_ms'?: number;
    /**
     * the finalised height of the observed transaction on the source chain, not provided if chain is MAYA
     * @type {number}
     * @memberof ObservedTx
     */
    'finalise_height'?: number;
    /**
     * the outbound aggregator to use, will also match a suffix
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator'?: string;
    /**
     * the aggregator target asset provided to transferOutAndCall
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator_target'?: string;
    /**
     * the aggregator target asset limit provided to transferOutAndCall
     * @type {string}
     * @memberof ObservedTx
     */
    'aggregator_target_limit'?: string;
}

export const ObservedTxStatusEnum = {
    Done: 'done',
    Incomplete: 'incomplete'
} as const;

export type ObservedTxStatusEnum = typeof ObservedTxStatusEnum[keyof typeof ObservedTxStatusEnum];

/**
 * 
 * @export
 * @interface OutboundResponse
 */
export interface OutboundResponse extends Array<TxOutItem> {
}
/**
 * 
 * @export
 * @interface POLResponse
 */
export interface POLResponse {
    /**
     * total amount of RUNE deposited into the pools
     * @type {string}
     * @memberof POLResponse
     */
    'cacao_deposited': string;
    /**
     * total amount of RUNE withdrawn from the pools
     * @type {string}
     * @memberof POLResponse
     */
    'cacao_withdrawn': string;
    /**
     * total value of protocol\'s LP position in RUNE value
     * @type {string}
     * @memberof POLResponse
     */
    'value': string;
    /**
     * profit and loss of protocol owned liquidity
     * @type {string}
     * @memberof POLResponse
     */
    'pnl': string;
    /**
     * current amount of rune deposited
     * @type {string}
     * @memberof POLResponse
     */
    'current_deposit': string;
}
/**
 * 
 * @export
 * @interface Ping
 */
export interface Ping {
    /**
     * 
     * @type {string}
     * @memberof Ping
     */
    'ping'?: string;
}
/**
 * 
 * @export
 * @interface Pool
 */
export interface Pool {
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'balance_cacao': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'balance_asset': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'asset': string;
    /**
     * the total pool liquidity provider units
     * @type {string}
     * @memberof Pool
     */
    'LP_units': string;
    /**
     * the total pool units, this is the sum of LP and synth units
     * @type {string}
     * @memberof Pool
     */
    'pool_units': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof Pool
     */
    'decimals'?: number;
    /**
     * the total synth units in the pool
     * @type {string}
     * @memberof Pool
     */
    'synth_units': string;
    /**
     * the total supply of synths for the asset
     * @type {string}
     * @memberof Pool
     */
    'synth_supply': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'pending_inbound_cacao': string;
    /**
     * 
     * @type {string}
     * @memberof Pool
     */
    'pending_inbound_asset': string;
}
/**
 * 
 * @export
 * @interface PoolsResponse
 */
export interface PoolsResponse extends Array<Pool> {
}
/**
 * 
 * @export
 * @interface QueueResponse
 */
export interface QueueResponse {
    /**
     * 
     * @type {number}
     * @memberof QueueResponse
     */
    'swap': number;
    /**
     * number of signed outbound tx in the queue
     * @type {number}
     * @memberof QueueResponse
     */
    'outbound': number;
    /**
     * 
     * @type {number}
     * @memberof QueueResponse
     */
    'internal': number;
    /**
     * scheduled outbound value in RUNE
     * @type {string}
     * @memberof QueueResponse
     */
    'scheduled_outbound_value': string;
}
/**
 * 
 * @export
 * @interface QuoteFees
 */
export interface QuoteFees {
    /**
     * 
     * @type {string}
     * @memberof QuoteFees
     */
    'asset': string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFees
     */
    'affiliate': string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFees
     */
    'outbound': string;
}
/**
 * 
 * @export
 * @interface QuoteSaverDepositResponse
 */
export interface QuoteSaverDepositResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'inbound_address': string;
    /**
     * generated memo for the deposit
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'memo': string;
    /**
     * the minimum amount of the target asset the user can expect to deposit after fees
     * @type {string}
     * @memberof QuoteSaverDepositResponse
     */
    'expected_amount_out': string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteSaverDepositResponse
     */
    'fees': QuoteFees;
    /**
     * the swap slippage in basis points
     * @type {number}
     * @memberof QuoteSaverDepositResponse
     */
    'slippage_bps': number;
}
/**
 * 
 * @export
 * @interface QuoteSaverWithdrawResponse
 */
export interface QuoteSaverWithdrawResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'inbound_address': string;
    /**
     * generated memo for the withdraw, the client can use this OR send the dust amount
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'memo': string;
    /**
     * the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'dust_amount': string;
    /**
     * the minimum amount of the target asset the user can expect to withdraw after fees in 1e8 decimals
     * @type {string}
     * @memberof QuoteSaverWithdrawResponse
     */
    'expected_amount_out': string;
    /**
     * the number of mayachain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'outbound_delay_blocks': number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'outbound_delay_seconds': number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteSaverWithdrawResponse
     */
    'fees': QuoteFees;
    /**
     * the swap slippage in basis points
     * @type {number}
     * @memberof QuoteSaverWithdrawResponse
     */
    'slippage_bps': number;
}
/**
 * 
 * @export
 * @interface QuoteSwapResponse
 */
export interface QuoteSwapResponse {
    /**
     * the inbound address for the transaction on the source chain
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'inbound_address': string;
    /**
     * generated memo for the swap
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'memo'?: string;
    /**
     * the minimum amount of the target asset the user can expect to receive after fees
     * @type {string}
     * @memberof QuoteSwapResponse
     */
    'expected_amount_out': string;
    /**
     * the approximate number of source chain blocks required before processing
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'inbound_confirmation_blocks'?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'inbound_confirmation_seconds'?: number;
    /**
     * the number of mayachain blocks the outbound will be delayed
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'outbound_delay_blocks': number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'outbound_delay_seconds': number;
    /**
     * 
     * @type {QuoteFees}
     * @memberof QuoteSwapResponse
     */
    'fees': QuoteFees;
    /**
     * the swap slippage in basis points
     * @type {number}
     * @memberof QuoteSwapResponse
     */
    'slippage_bps': number;
}
/**
 * 
 * @export
 * @interface ScheduledResponse
 */
export interface ScheduledResponse extends Array<TxOutItem> {
}
/**
 * 
 * @export
 * @interface TssKeysignMetric
 */
export interface TssKeysignMetric {
    /**
     * 
     * @type {string}
     * @memberof TssKeysignMetric
     */
    'tx_id'?: string;
    /**
     * 
     * @type {Array<TssMetric>}
     * @memberof TssKeysignMetric
     */
    'node_tss_times': Array<TssMetric>;
}
/**
 * 
 * @export
 * @interface TssMetric
 */
export interface TssMetric {
    /**
     * 
     * @type {string}
     * @memberof TssMetric
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof TssMetric
     */
    'tss_time'?: number;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'from_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'to_address'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    'gas': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface TxOutItem
 */
export interface TxOutItem {
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'chain': string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'to_address': string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'vault_pub_key'?: string;
    /**
     * 
     * @type {Coin}
     * @memberof TxOutItem
     */
    'coin': Coin;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'memo'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof TxOutItem
     */
    'max_gas': Array<Coin>;
    /**
     * 
     * @type {number}
     * @memberof TxOutItem
     */
    'gas_rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'in_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TxOutItem
     */
    'out_hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxOutItem
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface TxResponse
 */
export interface TxResponse {
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxResponse
     */
    'observed_tx'?: ObservedTx;
    /**
     * 
     * @type {TssKeysignMetric}
     * @memberof TxResponse
     */
    'keysign_metric'?: TssKeysignMetric;
}
/**
 * 
 * @export
 * @interface TxSignersResponse
 */
export interface TxSignersResponse {
    /**
     * 
     * @type {string}
     * @memberof TxSignersResponse
     */
    'tx_id'?: string;
    /**
     * 
     * @type {ObservedTx}
     * @memberof TxSignersResponse
     */
    'tx': ObservedTx;
    /**
     * 
     * @type {number}
     * @memberof TxSignersResponse
     */
    'height'?: number;
    /**
     * 
     * @type {Array<ObservedTx>}
     * @memberof TxSignersResponse
     */
    'txs': Array<ObservedTx>;
    /**
     * 
     * @type {Array<ObservedTx>}
     * @memberof TxSignersResponse
     */
    'actions': Array<ObservedTx>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TxSignersResponse
     */
    'out_txs': Array<string>;
    /**
     * the mayachain height at which the outbound was finalised
     * @type {number}
     * @memberof TxSignersResponse
     */
    'finalised_height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TxSignersResponse
     */
    'updated_vault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TxSignersResponse
     */
    'reverted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TxSignersResponse
     */
    'outbound_height'?: number;
}
/**
 * 
 * @export
 * @interface Vault
 */
export interface Vault {
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'block_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'pub_key'?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Vault
     */
    'coins': Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'type'?: VaultTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'status_since'?: number;
    /**
     * the list of node public keys which are members of the vault
     * @type {Array<string>}
     * @memberof Vault
     */
    'membership'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vault
     */
    'chains'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'inbound_tx_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    'outbound_tx_count'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Vault
     */
    'pending_tx_block_heights'?: Array<number>;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof Vault
     */
    'routers': Array<VaultRouter>;
    /**
     * 
     * @type {Array<VaultAddress>}
     * @memberof Vault
     */
    'addresses': Array<VaultAddress>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vault
     */
    'frozen'?: Array<string>;
}

export const VaultTypeEnum = {
    AsgardVault: 'AsgardVault',
    YggdrasilVault: 'YggdrasilVault'
} as const;

export type VaultTypeEnum = typeof VaultTypeEnum[keyof typeof VaultTypeEnum];

/**
 * 
 * @export
 * @interface VaultAddress
 */
export interface VaultAddress {
    /**
     * 
     * @type {string}
     * @memberof VaultAddress
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAddress
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface VaultInfo
 */
export interface VaultInfo {
    /**
     * 
     * @type {string}
     * @memberof VaultInfo
     */
    'pub_key': string;
    /**
     * 
     * @type {Array<VaultRouter>}
     * @memberof VaultInfo
     */
    'routers': Array<VaultRouter>;
}
/**
 * 
 * @export
 * @interface VaultPubkeysResponse
 */
export interface VaultPubkeysResponse {
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'asgard': Array<VaultInfo>;
    /**
     * 
     * @type {Array<VaultInfo>}
     * @memberof VaultPubkeysResponse
     */
    'yggdrasil': Array<VaultInfo>;
}
/**
 * 
 * @export
 * @interface VaultRouter
 */
export interface VaultRouter {
    /**
     * 
     * @type {string}
     * @memberof VaultRouter
     */
    'chain'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultRouter
     */
    'router'?: string;
}
/**
 * 
 * @export
 * @interface VaultsResponse
 */
export interface VaultsResponse extends Array<Vault> {
}
/**
 * 
 * @export
 * @interface VersionResponse
 */
export interface VersionResponse {
    /**
     * current version
     * @type {string}
     * @memberof VersionResponse
     */
    'current': string;
    /**
     * next version
     * @type {string}
     * @memberof VersionResponse
     */
    'next': string;
    /**
     * querier version
     * @type {string}
     * @memberof VersionResponse
     */
    'querier': string;
}

/**
 * BucketsApi - axios parameter creator
 * @export
 */
export const BucketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the bucket information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucket: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('bucket', 'asset', asset)
            const localVarPath = `/mayachain/bucket/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the bucket information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buckets: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/buckets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BucketsApi - functional programming interface
 * @export
 */
export const BucketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BucketsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the bucket information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bucket(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bucket(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the bucket information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buckets(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BucketsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buckets(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BucketsApi - factory interface
 * @export
 */
export const BucketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BucketsApiFp(configuration)
    return {
        /**
         * Returns the bucket information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bucket(asset: string, height?: number, options?: any): AxiosPromise<Bucket> {
            return localVarFp.bucket(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the bucket information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buckets(height?: number, options?: any): AxiosPromise<BucketsResponse> {
            return localVarFp.buckets(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BucketsApi - object-oriented interface
 * @export
 * @class BucketsApi
 * @extends {BaseAPI}
 */
export class BucketsApi extends BaseAPI {
    /**
     * Returns the bucket information for the provided asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public bucket(asset: string, height?: number, options?: AxiosRequestConfig) {
        return BucketsApiFp(this.configuration).bucket(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the bucket information for all assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BucketsApi
     */
    public buckets(height?: number, options?: AxiosRequestConfig) {
        return BucketsApiFp(this.configuration).buckets(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<Ping> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public ping(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiquidityProvidersApi - axios parameter creator
 * @export
 */
export const LiquidityProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider: async (asset: string, address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProvider', 'asset', asset)
            // verify required parameter 'address' is not null or undefined
            assertParamExists('liquidityProvider', 'address', address)
            const localVarPath = `/mayachain/pool/{asset}/liquidity_provider/{address}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)))
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('liquidityProviders', 'asset', asset)
            const localVarPath = `/mayachain/pool/{asset}/liquidity_providers`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiquidityProvidersApi - functional programming interface
 * @export
 */
export const LiquidityProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiquidityProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProvider(asset: string, address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProvider(asset, address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidityProviders(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidityProviders(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LiquidityProvidersApi - factory interface
 * @export
 */
export const LiquidityProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiquidityProvidersApiFp(configuration)
    return {
        /**
         * Returns the liquidity provider information for an address and asset.
         * @param {string} asset 
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProvider(asset: string, address: string, height?: number, options?: any): AxiosPromise<LiquidityProviderResponse> {
            return localVarFp.liquidityProvider(asset, address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all liquidity provider information for an asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidityProviders(asset: string, height?: number, options?: any): AxiosPromise<LiquidityProviderResponse> {
            return localVarFp.liquidityProviders(asset, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiquidityProvidersApi - object-oriented interface
 * @export
 * @class LiquidityProvidersApi
 * @extends {BaseAPI}
 */
export class LiquidityProvidersApi extends BaseAPI {
    /**
     * Returns the liquidity provider information for an address and asset.
     * @param {string} asset 
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    public liquidityProvider(asset: string, address: string, height?: number, options?: AxiosRequestConfig) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProvider(asset, address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all liquidity provider information for an asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiquidityProvidersApi
     */
    public liquidityProviders(asset: string, height?: number, options?: AxiosRequestConfig) {
        return LiquidityProvidersApiFp(this.configuration).liquidityProviders(asset, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MayanamesApi - axios parameter creator
 * @export
 */
export const MayanamesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns addresses registered to the provided mayaname.
         * @param {string} name the mayanode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mayaname: async (name: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('mayaname', 'name', name)
            const localVarPath = `/mayachain/mayaname/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MayanamesApi - functional programming interface
 * @export
 */
export const MayanamesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MayanamesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns addresses registered to the provided mayaname.
         * @param {string} name the mayanode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mayaname(name: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MayanameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mayaname(name, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MayanamesApi - factory interface
 * @export
 */
export const MayanamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MayanamesApiFp(configuration)
    return {
        /**
         * Returns addresses registered to the provided mayaname.
         * @param {string} name the mayanode to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mayaname(name: string, height?: number, options?: any): AxiosPromise<MayanameResponse> {
            return localVarFp.mayaname(name, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MayanamesApi - object-oriented interface
 * @export
 * @class MayanamesApi
 * @extends {BaseAPI}
 */
export class MayanamesApi extends BaseAPI {
    /**
     * Returns addresses registered to the provided mayaname.
     * @param {string} name the mayanode to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MayanamesApi
     */
    public mayaname(name: string, height?: number, options?: AxiosRequestConfig) {
        return MayanamesApiFp(this.configuration).mayaname(name, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MimirApi - axios parameter creator
 * @export
 */
export const MimirApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/mimir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/mimir/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey: async (key: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('mimirKey', 'key', key)
            const localVarPath = `/mayachain/mimir/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('mimirNode', 'address', address)
            const localVarPath = `/mayachain/mimir/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/mimir/nodes_all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MimirApi - functional programming interface
 * @export
 */
export const MimirApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MimirApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimir(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimir(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirAdmin(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirAdmin(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirKey(key: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirKey(key, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirNode(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirNode(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mimirNodes(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MimirNodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mimirNodes(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MimirApi - factory interface
 * @export
 */
export const MimirApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MimirApiFp(configuration)
    return {
        /**
         * Returns current active mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimir(height?: number, options?: any): AxiosPromise<MimirResponse> {
            return localVarFp.mimir(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current admin mimir configuration.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirAdmin(height?: number, options?: any): AxiosPromise<MimirResponse> {
            return localVarFp.mimirAdmin(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current active mimir configuration for the provided key.
         * @param {string} key the mimir key to lookup
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirKey(key: string, height?: number, options?: any): AxiosPromise<number> {
            return localVarFp.mimirKey(key, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir configuration for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNode(address: string, height?: number, options?: any): AxiosPromise<MimirResponse> {
            return localVarFp.mimirNode(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current node mimir votes.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mimirNodes(height?: number, options?: any): AxiosPromise<MimirNodesResponse> {
            return localVarFp.mimirNodes(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MimirApi - object-oriented interface
 * @export
 * @class MimirApi
 * @extends {BaseAPI}
 */
export class MimirApi extends BaseAPI {
    /**
     * Returns current active mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimir(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimir(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current admin mimir configuration.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirAdmin(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirAdmin(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current active mimir configuration for the provided key.
     * @param {string} key the mimir key to lookup
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirKey(key: string, height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirKey(key, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current node mimir configuration for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirNode(address: string, height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirNode(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current node mimir votes.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MimirApi
     */
    public mimirNodes(height?: number, options?: AxiosRequestConfig) {
        return MimirApiFp(this.configuration).mimirNodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('ban', 'address', address)
            const localVarPath = `/mayachain/ban/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain: async (chain: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('lastblockChain', 'chain', chain)
            const localVarPath = `/mayachain/lastblock/{chain}`
                .replace(`{${"chain"}}`, encodeURIComponent(String(chain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/ragnarok`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the network\'s current MAYANode version, the network\'s next MAYANode version, and the querier\'s MAYANode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ban(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ban(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constants(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.constants(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboundAddresses(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InboundAddressesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboundAddresses(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastblock(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastblock(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lastblockChain(chain: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lastblockChain(chain, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async network(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.network(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ragnarok(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ragnarok(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the network\'s current MAYANode version, the network\'s next MAYANode version, and the querier\'s MAYANode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async version(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.version(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * Returns the ban status for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ban(address: string, height?: number, options?: any): AxiosPromise<BanResponse> {
            return localVarFp.ban(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns constant configuration, can be overridden by mimir.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constants(height?: number, options?: any): AxiosPromise<ConstantsResponse> {
            return localVarFp.constants(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the set of asgard addresses that should be used for inbound transactions.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboundAddresses(height?: number, options?: any): AxiosPromise<InboundAddressesResponse> {
            return localVarFp.inboundAddresses(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for all chains.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblock(height?: number, options?: any): AxiosPromise<LastBlockResponse> {
            return localVarFp.lastblock(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the last block information for the provided chain.
         * @param {string} chain 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lastblockChain(chain: string, height?: number, options?: any): AxiosPromise<LastBlockResponse> {
            return localVarFp.lastblockChain(chain, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns network overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        network(height?: number, options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.network(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a boolean indicating whether the chain is in ragnarok.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ragnarok(height?: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.ragnarok(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the network\'s current MAYANode version, the network\'s next MAYANode version, and the querier\'s MAYANode version.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(height?: number, options?: any): AxiosPromise<VersionResponse> {
            return localVarFp.version(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * Returns the ban status for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public ban(address: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).ban(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns constant configuration, can be overridden by mimir.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public constants(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).constants(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the set of asgard addresses that should be used for inbound transactions.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public inboundAddresses(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).inboundAddresses(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for all chains.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public lastblock(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).lastblock(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the last block information for the provided chain.
     * @param {string} chain 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public lastblockChain(chain: string, height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).lastblockChain(chain, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns network overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public network(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).network(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a boolean indicating whether the chain is in ragnarok.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public ragnarok(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).ragnarok(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the network\'s current MAYANode version, the network\'s next MAYANode version, and the querier\'s MAYANode version.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public version(height?: number, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).version(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node: async (address: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('node', 'address', address)
            const localVarPath = `/mayachain/node/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async node(address: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Node>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.node(address, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodes(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodes(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * Returns node information for the provided node address.
         * @param {string} address 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        node(address: string, height?: number, options?: any): AxiosPromise<Node> {
            return localVarFp.node(address, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns node information for all registered validators.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodes(height?: number, options?: any): AxiosPromise<NodesResponse> {
            return localVarFp.nodes(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * Returns node information for the provided node address.
     * @param {string} address 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public node(address: string, height?: number, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).node(address, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns node information for all registered validators.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public nodes(height?: number, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).nodes(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * POLApi - axios parameter creator
 * @export
 */
export const POLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/pol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * POLApi - functional programming interface
 * @export
 */
export const POLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = POLApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pol(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<POLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pol(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * POLApi - factory interface
 * @export
 */
export const POLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = POLApiFp(configuration)
    return {
        /**
         * Returns protocol owned liquidity overview statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pol(height?: number, options?: any): AxiosPromise<POLResponse> {
            return localVarFp.pol(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * POLApi - object-oriented interface
 * @export
 * @class POLApi
 * @extends {BaseAPI}
 */
export class POLApi extends BaseAPI {
    /**
     * Returns protocol owned liquidity overview statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof POLApi
     */
    public pol(height?: number, options?: AxiosRequestConfig) {
        return POLApiFp(this.configuration).pol(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (asset: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('pool', 'asset', asset)
            const localVarPath = `/mayachain/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(asset: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pool(asset, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pools(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pools(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * Returns the pool information for the provided asset.
         * @param {string} asset 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(asset: string, height?: number, options?: any): AxiosPromise<Pool> {
            return localVarFp.pool(asset, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the pool information for all assets.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pools(height?: number, options?: any): AxiosPromise<PoolsResponse> {
            return localVarFp.pools(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * Returns the pool information for the provided asset.
     * @param {string} asset 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public pool(asset: string, height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).pool(asset, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the pool information for all assets.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public pools(height?: number, options?: AxiosRequestConfig) {
        return PoolsApiFp(this.configuration).pools(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueueApi - axios parameter creator
 * @export
 */
export const QueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/queue/outbound`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/queue/scheduled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueueApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queue(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queue(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueOutbound(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OutboundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueOutbound(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueScheduled(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduledResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queueScheduled(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueueApiFp(configuration)
    return {
        /**
         * Returns queue statistics.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queue(height?: number, options?: any): AxiosPromise<QueueResponse> {
            return localVarFp.queue(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the outbound queue including estimated RUNE values.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueOutbound(height?: number, options?: any): AxiosPromise<OutboundResponse> {
            return localVarFp.queueOutbound(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the scheduled queue.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueScheduled(height?: number, options?: any): AxiosPromise<ScheduledResponse> {
            return localVarFp.queueScheduled(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI {
    /**
     * Returns queue statistics.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queue(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queue(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the outbound queue including estimated RUNE values.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueOutbound(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueOutbound(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the scheduled queue.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public queueScheduled(height?: number, options?: AxiosRequestConfig) {
        return QueueApiFp(this.configuration).queueScheduled(height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuoteApi - axios parameter creator
 * @export
 */
export const QuoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide a quote estimate for the provided saver deposit.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to deposit
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverdeposit: async (height?: number, asset?: string, amount?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/quote/saver/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a quote estimate for the provided saver withdraw.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to withdraw
         * @param {string} [address] the address for the position
         * @param {number} [withdrawBps] the basis points of the existing position to withdraw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverwithdraw: async (height?: number, asset?: string, address?: string, withdrawBps?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/quote/saver/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (withdrawBps !== undefined) {
                localVarQueryParameter['withdraw_bps'] = withdrawBps;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a quote estimate for the provided swap.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the source asset
         * @param {string} [toAsset] the target asset
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {string} [destination] the destination address, required to generate memo
         * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or mayaname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteswap: async (height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/quote/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromAsset !== undefined) {
                localVarQueryParameter['from_asset'] = fromAsset;
            }

            if (toAsset !== undefined) {
                localVarQueryParameter['to_asset'] = toAsset;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (destination !== undefined) {
                localVarQueryParameter['destination'] = destination;
            }

            if (toleranceBps !== undefined) {
                localVarQueryParameter['tolerance_bps'] = toleranceBps;
            }

            if (affiliateBps !== undefined) {
                localVarQueryParameter['affiliate_bps'] = affiliateBps;
            }

            if (affiliate !== undefined) {
                localVarQueryParameter['affiliate'] = affiliate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteApi - functional programming interface
 * @export
 */
export const QuoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Provide a quote estimate for the provided saver deposit.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to deposit
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesaverdeposit(height?: number, asset?: string, amount?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteSaverDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesaverdeposit(height, asset, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a quote estimate for the provided saver withdraw.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to withdraw
         * @param {string} [address] the address for the position
         * @param {number} [withdrawBps] the basis points of the existing position to withdraw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotesaverwithdraw(height?: number, asset?: string, address?: string, withdrawBps?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteSaverWithdrawResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotesaverwithdraw(height, asset, address, withdrawBps, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a quote estimate for the provided swap.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the source asset
         * @param {string} [toAsset] the target asset
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {string} [destination] the destination address, required to generate memo
         * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or mayaname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quoteswap(height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteSwapResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quoteswap(height, fromAsset, toAsset, amount, destination, toleranceBps, affiliateBps, affiliate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuoteApi - factory interface
 * @export
 */
export const QuoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuoteApiFp(configuration)
    return {
        /**
         * Provide a quote estimate for the provided saver deposit.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to deposit
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverdeposit(height?: number, asset?: string, amount?: number, options?: any): AxiosPromise<QuoteSaverDepositResponse> {
            return localVarFp.quotesaverdeposit(height, asset, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a quote estimate for the provided saver withdraw.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [asset] the asset to withdraw
         * @param {string} [address] the address for the position
         * @param {number} [withdrawBps] the basis points of the existing position to withdraw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotesaverwithdraw(height?: number, asset?: string, address?: string, withdrawBps?: number, options?: any): AxiosPromise<QuoteSaverWithdrawResponse> {
            return localVarFp.quotesaverwithdraw(height, asset, address, withdrawBps, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a quote estimate for the provided swap.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {string} [fromAsset] the source asset
         * @param {string} [toAsset] the target asset
         * @param {number} [amount] the source asset amount in 1e8 decimals
         * @param {string} [destination] the destination address, required to generate memo
         * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
         * @param {number} [affiliateBps] the affiliate fee in basis points
         * @param {string} [affiliate] the affiliate (address or mayaname)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quoteswap(height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options?: any): AxiosPromise<QuoteSwapResponse> {
            return localVarFp.quoteswap(height, fromAsset, toAsset, amount, destination, toleranceBps, affiliateBps, affiliate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuoteApi - object-oriented interface
 * @export
 * @class QuoteApi
 * @extends {BaseAPI}
 */
export class QuoteApi extends BaseAPI {
    /**
     * Provide a quote estimate for the provided saver deposit.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [asset] the asset to deposit
     * @param {number} [amount] the source asset amount in 1e8 decimals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesaverdeposit(height?: number, asset?: string, amount?: number, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesaverdeposit(height, asset, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a quote estimate for the provided saver withdraw.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [asset] the asset to withdraw
     * @param {string} [address] the address for the position
     * @param {number} [withdrawBps] the basis points of the existing position to withdraw
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quotesaverwithdraw(height?: number, asset?: string, address?: string, withdrawBps?: number, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quotesaverwithdraw(height, asset, address, withdrawBps, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a quote estimate for the provided swap.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {string} [fromAsset] the source asset
     * @param {string} [toAsset] the target asset
     * @param {number} [amount] the source asset amount in 1e8 decimals
     * @param {string} [destination] the destination address, required to generate memo
     * @param {number} [toleranceBps] the maximum basis points from the current feeless swap price to set the limit in the generated memo
     * @param {number} [affiliateBps] the affiliate fee in basis points
     * @param {string} [affiliate] the affiliate (address or mayaname)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public quoteswap(height?: number, fromAsset?: string, toAsset?: string, amount?: number, destination?: string, toleranceBps?: number, affiliateBps?: number, affiliate?: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).quoteswap(height, fromAsset, toAsset, amount, destination, toleranceBps, affiliateBps, affiliate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TSSApi - axios parameter creator
 * @export
 */
export const TSSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign: async (height: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysign', 'height', height)
            const localVarPath = `/mayachain/keysign/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey: async (height: number, pubkey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('keysignPubkey', 'height', height)
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('keysignPubkey', 'pubkey', pubkey)
            const localVarPath = `/mayachain/keysign/{height}/{pubkey}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen: async (pubkey: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('metricsKeygen', 'pubkey', pubkey)
            const localVarPath = `/mayachain/metric/keygen/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TSSApi - functional programming interface
 * @export
 */
export const TSSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TSSApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysign(height: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysign(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keysignPubkey(height: number, pubkey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keysignPubkey(height, pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsKeygen(pubkey: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeygenMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsKeygen(pubkey, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TSSApi - factory interface
 * @export
 */
export const TSSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TSSApiFp(configuration)
    return {
        /**
         * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
         * @param {number} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysign(height: number, options?: any): AxiosPromise<KeysignResponse> {
            return localVarFp.keysign(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
         * @param {number} height 
         * @param {string} pubkey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keysignPubkey(height: number, pubkey: string, options?: any): AxiosPromise<KeysignResponse> {
            return localVarFp.keysignPubkey(height, pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen and keysign metrics for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(height?: number, options?: any): AxiosPromise<MetricsResponse> {
            return localVarFp.metrics(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns keygen metrics for the provided vault pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsKeygen(pubkey: string, height?: number, options?: any): AxiosPromise<KeygenMetricsResponse> {
            return localVarFp.metricsKeygen(pubkey, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TSSApi - object-oriented interface
 * @export
 * @class TSSApi
 * @extends {BaseAPI}
 */
export class TSSApi extends BaseAPI {
    /**
     * Returns keysign information for the provided height - the height being the first block a tx out item appears in the signed-but-unobserved outbound queue.
     * @param {number} height 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keysign(height: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keysign(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keysign information for the provided height and pubkey - the height being the block at which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue.
     * @param {number} height 
     * @param {string} pubkey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public keysignPubkey(height: number, pubkey: string, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).keysignPubkey(height, pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keygen and keysign metrics for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public metrics(height?: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).metrics(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns keygen metrics for the provided vault pubkey.
     * @param {string} pubkey 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TSSApi
     */
    public metricsKeygen(pubkey: string, height?: number, options?: AxiosRequestConfig) {
        return TSSApiFp(this.configuration).metricsKeygen(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('tx', 'hash', hash)
            const localVarPath = `/mayachain/tx/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners: async (hash: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txSigners', 'hash', hash)
            const localVarPath = `/mayachain/tx/{hash}/signers`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tx(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tx(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txSigners(hash: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxSignersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txSigners(hash, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Returns the observed transaction for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx(hash: string, height?: number, options?: any): AxiosPromise<TxResponse> {
            return localVarFp.tx(hash, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the signers for a provided inbound or outbound hash.
         * @param {string} hash 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txSigners(hash: string, height?: number, options?: any): AxiosPromise<TxSignersResponse> {
            return localVarFp.txSigners(hash, height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Returns the observed transaction for a provided inbound or outbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public tx(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).tx(hash, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the signers for a provided inbound or outbound hash.
     * @param {string} hash 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public txSigners(hash: string, height?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).txSigners(hash, height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VaultsApi - axios parameter creator
 * @export
 */
export const VaultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/vaults/asgard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault: async (pubkey: string, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('vault', 'pubkey', pubkey)
            const localVarPath = `/mayachain/vaults/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/vaults/pubkeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil: async (height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mayachain/vaults/yggdrasil`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VaultsApi - functional programming interface
 * @export
 */
export const VaultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VaultsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asgard(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asgard(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vault(pubkey: string, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vault(pubkey, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vaultPubkeys(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultPubkeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vaultPubkeys(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async yggdrasil(height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.yggdrasil(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VaultsApi - factory interface
 * @export
 */
export const VaultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VaultsApiFp(configuration)
    return {
        /**
         * Returns current asgard vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asgard(height?: number, options?: any): AxiosPromise<VaultsResponse> {
            return localVarFp.asgard(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the vault for the provided pubkey.
         * @param {string} pubkey 
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vault(pubkey: string, height?: number, options?: any): AxiosPromise<Vault> {
            return localVarFp.vault(pubkey, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all pubkeys for current vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vaultPubkeys(height?: number, options?: any): AxiosPromise<VaultPubkeysResponse> {
            return localVarFp.vaultPubkeys(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current yggdrasil vaults.
         * @param {number} [height] optional block height, defaults to current tip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yggdrasil(height?: number, options?: any): AxiosPromise<VaultsResponse> {
            return localVarFp.yggdrasil(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
export class VaultsApi extends BaseAPI {
    /**
     * Returns current asgard vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public asgard(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).asgard(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the vault for the provided pubkey.
     * @param {string} pubkey 
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public vault(pubkey: string, height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).vault(pubkey, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all pubkeys for current vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public vaultPubkeys(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).vaultPubkeys(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current yggdrasil vaults.
     * @param {number} [height] optional block height, defaults to current tip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    public yggdrasil(height?: number, options?: AxiosRequestConfig) {
        return VaultsApiFp(this.configuration).yggdrasil(height, options).then((request) => request(this.axios, this.basePath));
    }
}


