/* tslint:disable */
/* eslint-disable */
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifr√∂st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 2.10.0
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * action details among with related transactions
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * Int64, nano timestamp of the block at which the action was registered
     * @type {string}
     * @memberof Action
     */
    'date': string;
    /**
     * Int64, height of the block at which the action was registered
     * @type {string}
     * @memberof Action
     */
    'height': string;
    /**
     * Inbound transactions related to the action
     * @type {Array<Transaction>}
     * @memberof Action
     */
    'in': Array<Transaction>;
    /**
     * 
     * @type {Metadata}
     * @memberof Action
     */
    'metadata': Metadata;
    /**
     * Outbound transactions related to the action
     * @type {Array<Transaction>}
     * @memberof Action
     */
    'out': Array<Transaction>;
    /**
     * Pools involved in the action
     * @type {Array<string>}
     * @memberof Action
     */
    'pools': Array<string>;
    /**
     * Indicates if the action is completed or if related outbound transactions are still pending. 
     * @type {string}
     * @memberof Action
     */
    'status': ActionStatusEnum;
    /**
     * Type of action
     * @type {string}
     * @memberof Action
     */
    'type': ActionTypeEnum;
}

export const ActionStatusEnum = {
    Success: 'success',
    Pending: 'pending'
} as const;

export type ActionStatusEnum = typeof ActionStatusEnum[keyof typeof ActionStatusEnum];
export const ActionTypeEnum = {
    Swap: 'swap',
    AddLiquidity: 'addLiquidity',
    Withdraw: 'withdraw',
    Donate: 'donate',
    Refund: 'refund',
    Switch: 'switch'
} as const;

export type ActionTypeEnum = typeof ActionTypeEnum[keyof typeof ActionTypeEnum];

/**
 * 
 * @export
 * @interface AddLiquidityMetadata
 */
export interface AddLiquidityMetadata {
    /**
     * Int64, amount of liquidity units assigned to the member as result of the liquidity deposit 
     * @type {string}
     * @memberof AddLiquidityMetadata
     */
    'liquidityUnits': string;
}
/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {Coins}
     * @memberof Balance
     */
    'coins': Coins;
    /**
     * full timestamp (nanoseconds since 1970) of the block at which the returned balance snapshot was valid
     * @type {string}
     * @memberof Balance
     */
    'date': string;
    /**
     * height of the block at which the returned balance snapshot was valid
     * @type {string}
     * @memberof Balance
     */
    'height': string;
}
/**
 * 
 * @export
 * @interface BlockRewards
 */
export interface BlockRewards {
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    'blockReward': string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    'bondReward': string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    'poolReward': string;
}
/**
 * 
 * @export
 * @interface BondMetrics
 */
export interface BondMetrics {
    /**
     * Int64(e8), Average bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'averageActiveBond': string;
    /**
     * Int64(e8), Average bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'averageStandbyBond': string;
    /**
     * Int64(e8), Maxinum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'maximumActiveBond': string;
    /**
     * Int64(e8), Maximum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'maximumStandbyBond': string;
    /**
     * Int64(e8), Median bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'medianActiveBond': string;
    /**
     * Int64(e8), Median bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'medianStandbyBond': string;
    /**
     * Int64(e8), Minumum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'minimumActiveBond': string;
    /**
     * Int64(e8), Minumum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'minimumStandbyBond': string;
    /**
     * Int64(e8), Total bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'totalActiveBond': string;
    /**
     * Int64(e8), Total bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    'totalStandbyBond': string;
}
/**
 * 
 * @export
 * @interface ChurnItem
 */
export interface ChurnItem {
    /**
     * full timestamp (nanoseconds since 1970) of the block at which the churn occurred
     * @type {string}
     * @memberof ChurnItem
     */
    'date': string;
    /**
     * height of the block at which the churn occurred
     * @type {string}
     * @memberof ChurnItem
     */
    'height': string;
}
/**
 * 
 * @export
 * @interface Churns
 */
export interface Churns extends Array<ChurnItem> {
}
/**
 * Represents a digital currency amount
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * Int64(e8), asset Amount.
     * @type {string}
     * @memberof Coin
     */
    'amount': string;
    /**
     * Asset in CHAIN.SYMBOL format
     * @type {string}
     * @memberof Coin
     */
    'asset': string;
}
/**
 * 
 * @export
 * @interface Coins
 */
export interface Coins extends Array<Coin> {
}
/**
 * 
 * @export
 * @interface DepthHistory
 */
export interface DepthHistory {
    /**
     * 
     * @type {DepthHistoryIntervals}
     * @memberof DepthHistory
     */
    'intervals': DepthHistoryIntervals;
    /**
     * 
     * @type {DepthHistoryMeta}
     * @memberof DepthHistory
     */
    'meta': DepthHistoryMeta;
}
/**
 * 
 * @export
 * @interface DepthHistoryIntervals
 */
export interface DepthHistoryIntervals extends Array<DepthHistoryItem> {
}
/**
 * 
 * @export
 * @interface DepthHistoryItem
 */
export interface DepthHistoryItem {
    /**
     * Int64(e8), the amount of Asset in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'assetDepth': string;
    /**
     * Float, price of asset in rune. I.e. rune amount / asset amount
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'assetPrice': string;
    /**
     * Float, the price of asset in USD (based on the deepest USD pool).
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'assetPriceUSD': string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'endTime': string;
    /**
     * Int64, Liquidity Units in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'liquidityUnits': string;
    /**
     * Float, The liquidity unit value index. Sqrt(assetDepth * runeDepth)/liquidity units 
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'luvi': string;
    /**
     * Int64(e8), the amount of Rune in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'runeDepth': string;
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'startTime': string;
    /**
     * Int64, Synth supply in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'synthSupply': string;
    /**
     * Int64, Synth Units in the pool at the end of the interval
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'synthUnits': string;
    /**
     * Int64, Total Units (synthUnits + liquidityUnits) in the pool at the end of the interval 
     * @type {string}
     * @memberof DepthHistoryItem
     */
    'units': string;
}
/**
 * 
 * @export
 * @interface DepthHistoryMeta
 */
export interface DepthHistoryMeta {
    /**
     * Int64(e8), the amount of Asset in the pool at the end of the interval at time endTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'endAssetDepth': string;
    /**
     * Int64, Liquidity Units in the pool at the end of the interval at time endTime
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'endLPUnits': string;
    /**
     * Int64(e8), the amount of Rune in the pool at the end of the interval at time endTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'endRuneDepth': string;
    /**
     * Int64, Synth Units in the pool at the end of the interval at time endTime
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'endSynthUnits': string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'endTime': string;
    /**
     * Float, The liquidity unit value index increase between startTime and endTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'luviIncrease': string;
    /**
     * Float, The impermanent loss between the first and last depth item
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'priceShiftLoss': string;
    /**
     * Int64(e8), the amount of Asset in the pool at the start of the interval at time startTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'startAssetDepth': string;
    /**
     * Int64, Liquidity Units in the pool at the start of the interval at time startTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'startLPUnits': string;
    /**
     * Int64(e8), the amount of Rune in the pool at the start of the interval at time startTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'startRuneDepth': string;
    /**
     * Int64, Synth Units in the pool at the start of the interval at time startTime 
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'startSynthUnits': string;
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof DepthHistoryMeta
     */
    'startTime': string;
}
/**
 * 
 * @export
 * @interface EarningsHistory
 */
export interface EarningsHistory {
    /**
     * 
     * @type {EarningsHistoryIntervals}
     * @memberof EarningsHistory
     */
    'intervals': EarningsHistoryIntervals;
    /**
     * 
     * @type {EarningsHistoryItem}
     * @memberof EarningsHistory
     */
    'meta': EarningsHistoryItem;
}
/**
 * 
 * @export
 * @interface EarningsHistoryIntervals
 */
export interface EarningsHistoryIntervals extends Array<EarningsHistoryItem> {
}
/**
 * 
 * @export
 * @interface EarningsHistoryItem
 */
export interface EarningsHistoryItem {
    /**
     * float64, Average amount of active nodes during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'avgNodeCount': string;
    /**
     * Int64(e8), Total block rewards emitted during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'blockRewards': string;
    /**
     * Int64(e8), Share of earnings sent to nodes during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'bondingEarnings': string;
    /**
     * Int64(e8), System income generated during the time interval. It is the sum of liquidity fees and block rewards 
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'earnings': string;
    /**
     * Int64, The end time of interval in unix timestamp
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'endTime': string;
    /**
     * Int64(e8), Share of earnings sent to pools during the time interval
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'liquidityEarnings': string;
    /**
     * Int64(e8), Total liquidity fees, converted to RUNE, collected during the time interval 
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'liquidityFees': string;
    /**
     * Earnings data for each pool for the time interval
     * @type {Array<EarningsHistoryItemPool>}
     * @memberof EarningsHistoryItem
     */
    'pools': Array<EarningsHistoryItemPool>;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'runePriceUSD': string;
    /**
     * Int64, The beginning time of interval in unix timestamp
     * @type {string}
     * @memberof EarningsHistoryItem
     */
    'startTime': string;
}
/**
 * pool earnings data during the time interval
 * @export
 * @interface EarningsHistoryItemPool
 */
export interface EarningsHistoryItemPool {
    /**
     * Int64(e8), liquidity fees collected in the pool\'s asset
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    'assetLiquidityFees': string;
    /**
     * Int64(e8), total earnings in RUNE (totalLiquidityFees + rewards)
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    'earnings': string;
    /**
     * asset for the given pool
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    'pool': string;
    /**
     * Int64(e8), RUNE amount sent to (positive) or taken from (negative) the pool as a result of balancing it\'s share of system income each block 
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    'rewards': string;
    /**
     * Int64(e8), liquidity fees collected in RUNE
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    'runeLiquidityFees': string;
    /**
     * Int64(e8), total liquidity fees (assetFees + runeFees) collected, shown in RUNE 
     * @type {string}
     * @memberof EarningsHistoryItemPool
     */
    'totalLiquidityFeesRune': string;
}
/**
 * 
 * @export
 * @interface Health
 */
export interface Health {
    /**
     * True means healthy, connected to database
     * @type {boolean}
     * @memberof Health
     */
    'database': boolean;
    /**
     * True means healthy. False means Midgard is still catching up to the chain
     * @type {boolean}
     * @memberof Health
     */
    'inSync': boolean;
    /**
     * 
     * @type {HeightTS}
     * @memberof Health
     */
    'lastAggregated': HeightTS;
    /**
     * 
     * @type {HeightTS}
     * @memberof Health
     */
    'lastCommitted': HeightTS;
    /**
     * 
     * @type {HeightTS}
     * @memberof Health
     */
    'lastFetched': HeightTS;
    /**
     * 
     * @type {HeightTS}
     * @memberof Health
     */
    'lastThorNode': HeightTS;
    /**
     * Int64, the current block count
     * @type {string}
     * @memberof Health
     */
    'scannerHeight': string;
}
/**
 * 
 * @export
 * @interface HeightTS
 */
export interface HeightTS {
    /**
     * Block height
     * @type {number}
     * @memberof HeightTS
     */
    'height': number;
    /**
     * Block timestamp (seconds since epoch)
     * @type {number}
     * @memberof HeightTS
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Action>}
     * @memberof InlineResponse200
     */
    'actions': Array<Action>;
    /**
     * Int64, number of results matching the given filters.
     * @type {string}
     * @memberof InlineResponse200
     */
    'count': string;
}
/**
 * 
 * @export
 * @interface KnownPools
 */
export interface KnownPools {
    [key: string]: string;

}
/**
 * 
 * @export
 * @interface LiquidityHistory
 */
export interface LiquidityHistory {
    /**
     * 
     * @type {LiquidityHistoryIntervals}
     * @memberof LiquidityHistory
     */
    'intervals': LiquidityHistoryIntervals;
    /**
     * 
     * @type {LiquidityHistoryItem}
     * @memberof LiquidityHistory
     */
    'meta': LiquidityHistoryItem;
}
/**
 * 
 * @export
 * @interface LiquidityHistoryIntervals
 */
export interface LiquidityHistoryIntervals extends Array<LiquidityHistoryItem> {
}
/**
 * 
 * @export
 * @interface LiquidityHistoryItem
 */
export interface LiquidityHistoryItem {
    /**
     * Int64(e8), total assets deposited during the time interval. Denoted in Rune using the price at deposit time. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'addAssetLiquidityVolume': string;
    /**
     * Int64, number of deposits during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'addLiquidityCount': string;
    /**
     * Int64(e8), total of rune and asset deposits. Denoted in Rune (using the price at deposit time). 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'addLiquidityVolume': string;
    /**
     * Int64(e8), total Rune deposited during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'addRuneLiquidityVolume': string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'endTime': string;
    /**
     * Int64(e8), part of the withdrawRuneVolume which was payed because of impermanent loss protection. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'impermanentLossProtectionPaid': string;
    /**
     * Int64(e8), net liquidity changes (withdrawals - deposits) during the time interval 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'net': string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'runePriceUSD': string;
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'startTime': string;
    /**
     * Int64(e8), total assets withdrawn during the time interval. Denoted in Rune using the price at withdraw time. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'withdrawAssetVolume': string;
    /**
     * Int64, number of withdraw during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'withdrawCount': string;
    /**
     * Int64(e8), total Rune withdrawn during the time interval. 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'withdrawRuneVolume': string;
    /**
     * Int64(e8), total of rune and asset withdrawals. Denoted in Rune (using the price at withdraw time). 
     * @type {string}
     * @memberof LiquidityHistoryItem
     */
    'withdrawVolume': string;
}
/**
 * 
 * @export
 * @interface MemberDetails
 */
export interface MemberDetails {
    /**
     * List details of all the liquidity providers identified with the given address
     * @type {Array<MemberPool>}
     * @memberof MemberDetails
     */
    'pools': Array<MemberPool>;
}
/**
 * 
 * @export
 * @interface MemberPool
 */
export interface MemberPool {
    /**
     * Int64(e8), total asset added to the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    'assetAdded': string;
    /**
     * asset address used by the member
     * @type {string}
     * @memberof MemberPool
     */
    'assetAddress': string;
    /**
     * Int64(e8), asset sent but not added yet, it will be added when the rune pair arrives 
     * @type {string}
     * @memberof MemberPool
     */
    'assetPending': string;
    /**
     * Int64(e8), total asset withdrawn from the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    'assetWithdrawn': string;
    /**
     * Int64, Unix timestamp for the first time member deposited into the pool
     * @type {string}
     * @memberof MemberPool
     */
    'dateFirstAdded': string;
    /**
     * Int64, Unix timestamp for the last time member deposited into the pool
     * @type {string}
     * @memberof MemberPool
     */
    'dateLastAdded': string;
    /**
     * Int64, pool liquidity units that belong the the member
     * @type {string}
     * @memberof MemberPool
     */
    'liquidityUnits': string;
    /**
     * Pool rest of the data refers to
     * @type {string}
     * @memberof MemberPool
     */
    'pool': string;
    /**
     * Int64(e8), total Rune added to the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    'runeAdded': string;
    /**
     * Rune address used by the member
     * @type {string}
     * @memberof MemberPool
     */
    'runeAddress': string;
    /**
     * Int64(e8), Rune sent but not added yet, it will be added when the asset pair arrives 
     * @type {string}
     * @memberof MemberPool
     */
    'runePending': string;
    /**
     * Int64(e8), total Rune withdrawn from the pool by member
     * @type {string}
     * @memberof MemberPool
     */
    'runeWithdrawn': string;
}
/**
 * 
 * @export
 * @interface Members
 */
export interface Members extends Array<string> {
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {AddLiquidityMetadata}
     * @memberof Metadata
     */
    'addLiquidity'?: AddLiquidityMetadata;
    /**
     * 
     * @type {RefundMetadata}
     * @memberof Metadata
     */
    'refund'?: RefundMetadata;
    /**
     * 
     * @type {SwapMetadata}
     * @memberof Metadata
     */
    'swap'?: SwapMetadata;
    /**
     * 
     * @type {WithdrawMetadata}
     * @memberof Metadata
     */
    'withdraw'?: WithdrawMetadata;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * Array of rune amounts (e8) bonded by each active node. 
     * @type {Array<string>}
     * @memberof Network
     */
    'activeBonds': Array<string>;
    /**
     * Int64, Number of active nodes
     * @type {string}
     * @memberof Network
     */
    'activeNodeCount': string;
    /**
     * 
     * @type {BlockRewards}
     * @memberof Network
     */
    'blockRewards': BlockRewards;
    /**
     * 
     * @type {BondMetrics}
     * @memberof Network
     */
    'bondMetrics': BondMetrics;
    /**
     * Float, E.g. 0.01 = 1%. Estimate of the compounded bonding earnings based on the current reserve size, emmission curve, blocks per year and pool share factor = (WeeklyBondIncome/BondAmount + 1)^52 - 1 
     * @type {string}
     * @memberof Network
     */
    'bondingAPY': string;
    /**
     * Float, E.g. 0.01 = 1%. Estimate of the compounded  liquidity provider earnings based on the current reserve size, emmission curve, blocks per year and pool share factor = (WeeklyLiquidityIncome/(totalPooledRune*2) + 1)^52 - 1 
     * @type {string}
     * @memberof Network
     */
    'liquidityAPY': string;
    /**
     * Int64, height (block number) of the next churn.
     * @type {string}
     * @memberof Network
     */
    'nextChurnHeight': string;
    /**
     * Int64, the remaining time of pool activation (in blocks)
     * @type {string}
     * @memberof Network
     */
    'poolActivationCountdown': string;
    /**
     * Float [0..1], the ratio which is used to split earnings between liquidity provider and nodes. LPIncome = rewards * poolShareFactor ; BondIncome :=  rewards * (1 - poolShareFactor) 
     * @type {string}
     * @memberof Network
     */
    'poolShareFactor': string;
    /**
     * Array of rune amounts (e8) bonded by each standby node. 
     * @type {Array<string>}
     * @memberof Network
     */
    'standbyBonds': Array<string>;
    /**
     * Int64, Number of standby nodes, some of them might become active at the next churn. 
     * @type {string}
     * @memberof Network
     */
    'standbyNodeCount': string;
    /**
     * Int64(e8), total Rune in all pools. Because asset and Rune value is the same amount in every pool (by definition), the total amount pooled is totalPooledRune*2. 
     * @type {string}
     * @memberof Network
     */
    'totalPooledRune': string;
    /**
     * Int64(e8), Current size of the Reserve.
     * @type {string}
     * @memberof Network
     */
    'totalReserve': string;
}
/**
 * List of network fees associated to an action. One network fee is charged for each outbound transaction 
 * @export
 * @interface NetworkFees
 */
export interface NetworkFees extends Array<Coin> {
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * ed25519 public key
     * @type {string}
     * @memberof Node
     */
    'ed25519': string;
    /**
     * node thorchain address
     * @type {string}
     * @memberof Node
     */
    'nodeAddress': string;
    /**
     * secp256k1 public key
     * @type {string}
     * @memberof Node
     */
    'secp256k1': string;
}
/**
 * 
 * @export
 * @interface Nodes
 */
export interface Nodes extends Array<Node> {
}
/**
 * 
 * @export
 * @interface PoolDetail
 */
export interface PoolDetail {
    /**
     * Float, Also called APR. Annual return estimated linearly (not compounded) from a period of typically the last 30 or 100 days (configurable by the period parameter, default is 30). E.g. 0.1 means 10% yearly return. Due to Impermanent Loss and Synths this might be negative, but given Impermanent Loss Protection for 100+ day members, frontends might show MAX(APR, 0). 
     * @type {string}
     * @memberof PoolDetail
     */
    'annualPercentageRate': string;
    /**
     * 
     * @type {string}
     * @memberof PoolDetail
     */
    'asset': string;
    /**
     * Int64(e8), the amount of Asset in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    'assetDepth': string;
    /**
     * Float, price of asset in rune. I.e. rune amount / asset amount.
     * @type {string}
     * @memberof PoolDetail
     */
    'assetPrice': string;
    /**
     * Float, the price of asset in USD (based on the deepest USD pool).
     * @type {string}
     * @memberof PoolDetail
     */
    'assetPriceUSD': string;
    /**
     * Int64, Liquidity Units in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    'liquidityUnits': string;
    /**
     * Int64, The native decimal number of the pool asset. (If the value is \"-1\", it means midgard doesn\'t know the pool native decimal)
     * @type {string}
     * @memberof PoolDetail
     */
    'nativeDecimal': string;
    /**
     * Float, MAX(AnnualPercentageRate, 0) 
     * @type {string}
     * @memberof PoolDetail
     */
    'poolAPY': string;
    /**
     * Int64(e8), the amount of Rune in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    'runeDepth': string;
    /**
     * Int64, Total synth locked in saver vault.
     * @type {string}
     * @memberof PoolDetail
     */
    'saversDepth': string;
    /**
     * Int64, Units tracking savers vault ownership.
     * @type {string}
     * @memberof PoolDetail
     */
    'saversUnits': string;
    /**
     * The state of the pool, e.g. Available, Staged.
     * @type {string}
     * @memberof PoolDetail
     */
    'status': string;
    /**
     * Int64, Synth supply in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    'synthSupply': string;
    /**
     * Int64, Synth Units in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    'synthUnits': string;
    /**
     * Int64, Total Units (synthUnits + liquidityUnits) in the pool.
     * @type {string}
     * @memberof PoolDetail
     */
    'units': string;
    /**
     * Int64(e8), the total volume of swaps in the last 24h to and from Rune denoted in Rune. It includes synth mint or burn. 
     * @type {string}
     * @memberof PoolDetail
     */
    'volume24h': string;
}
/**
 * 
 * @export
 * @interface PoolDetails
 */
export interface PoolDetails extends Array<PoolDetail> {
}
/**
 * 
 * @export
 * @interface PoolStatsDetail
 */
export interface PoolStatsDetail {
    /**
     * Int64(e8), same as history/liquidity_changes:addAssetLiquidityVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'addAssetLiquidityVolume': string;
    /**
     * Int64, same as history/liquidity_changes:addLiquidityCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'addLiquidityCount': string;
    /**
     * Int64(e8), same as history/liquidity_changes:addLiquidityVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'addLiquidityVolume': string;
    /**
     * Int64(e8), same as history/liquidity_changes:addRuneLiquidityVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'addRuneLiquidityVolume': string;
    /**
     * Float, Also called APR. Annual return estimated linearly (not compounded) from a period of typically the last 30 or 100 days (configurable by the period parameter, default is 30). E.g. 0.1 means 10% yearly return. Due to Impermanent Loss and Synths this might be negative, but given Impermanent Loss Protection for 100+ day members, frontends might show MAX(APR, 0). 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'annualPercentageRate': string;
    /**
     * 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'asset': string;
    /**
     * Int64(e8), the amount of Asset in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'assetDepth': string;
    /**
     * Float, price of asset in rune. I.e. rune amount / asset amount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'assetPrice': string;
    /**
     * Float, the price of asset in USD (based on the deepest USD pool).
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'assetPriceUSD': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:averageSlip 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'averageSlip': string;
    /**
     * Int64(e8), part of the withdrawRuneVolume which was payed because of impermanent loss protection. 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'impermanentLossProtectionPaid': string;
    /**
     * Int64, Liquidity Units in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'liquidityUnits': string;
    /**
     * Float, MAX(AnnualPercentageRate, 0) 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'poolAPY': string;
    /**
     * Int64(e8), the amount of Rune in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'runeDepth': string;
    /**
     * The state of the pool, e.g. Available, Staged
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'status': string;
    /**
     * Int64, same as history/swaps:totalCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'swapCount': string;
    /**
     * Int64(e8), same as history/swaps:totalVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'swapVolume': string;
    /**
     * Int64, Synth supply in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'synthSupply': string;
    /**
     * Int64, Synth Units in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'synthUnits': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:toAssetAverageSlip 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toAssetAverageSlip': string;
    /**
     * Int64, same as history/swaps:toAssetCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toAssetCount': string;
    /**
     * Int64(e8), same as history/swaps:toAssetFees
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toAssetFees': string;
    /**
     * Int64(e8), same as history/swaps:toAssetVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toAssetVolume': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:toRuneAverageSlip 
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toRuneAverageSlip': string;
    /**
     * Int64, same as history/swaps:toRuneCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toRuneCount': string;
    /**
     * Int64(e8), same as history/swaps:toRuneFees
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toRuneFees': string;
    /**
     * Int64(e8), same as history/swaps:toRuneVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'toRuneVolume': string;
    /**
     * Int64(e8), same as history/swaps:totalFees
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'totalFees': string;
    /**
     * Int64, same as len(history/members?pool=POOL)
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'uniqueMemberCount': string;
    /**
     * Deprecated, it\'s always 0.
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'uniqueSwapperCount': string;
    /**
     * Int64, Total Units (synthUnits + liquidityUnits) in the pool
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'units': string;
    /**
     * Int64(e8), same as history/liquidity_changes:withdrawAssetVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'withdrawAssetVolume': string;
    /**
     * Int64, same as history/liquidity_changes:withdrawCount
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'withdrawCount': string;
    /**
     * Int64(e8), same as history/liquidity_changes:withdrawRuneVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'withdrawRuneVolume': string;
    /**
     * Int64(e8), same as history/liquidity_changes:withdrawVolume
     * @type {string}
     * @memberof PoolStatsDetail
     */
    'withdrawVolume': string;
}
/**
 * 
 * @export
 * @interface RefundMetadata
 */
export interface RefundMetadata {
    /**
     * Transaction memo of the refund action
     * @type {string}
     * @memberof RefundMetadata
     */
    'memo': string;
    /**
     * 
     * @type {NetworkFees}
     * @memberof RefundMetadata
     */
    'networkFees': NetworkFees;
    /**
     * Reason for the refund
     * @type {string}
     * @memberof RefundMetadata
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface ReverseTHORNames
 */
export interface ReverseTHORNames extends Array<string> {
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * Int64, number of deposits since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'addLiquidityCount': string;
    /**
     * Int64(e8), total of deposits since beginning. 
     * @type {string}
     * @memberof StatsData
     */
    'addLiquidityVolume': string;
    /**
     * Deprecated, it\'s always 0.
     * @type {string}
     * @memberof StatsData
     */
    'dailyActiveUsers': string;
    /**
     * Int64(e8), impermanent loss protection paid out. 
     * @type {string}
     * @memberof StatsData
     */
    'impermanentLossProtectionPaid': string;
    /**
     * Deprecated, it\'s always 0.
     * @type {string}
     * @memberof StatsData
     */
    'monthlyActiveUsers': string;
    /**
     * Int64(e8), current total Rune in the pools.
     * @type {string}
     * @memberof StatsData
     */
    'runeDepth': string;
    /**
     * Float, the price of Rune based on the deepest USD pool.
     * @type {string}
     * @memberof StatsData
     */
    'runePriceUSD': string;
    /**
     * Int64, number of swaps (including synths) since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'swapCount': string;
    /**
     * Int64(e8), number of swaps (including synths) in the last 24h.
     * @type {string}
     * @memberof StatsData
     */
    'swapCount24h': string;
    /**
     * Int64, number of swaps (including synths) in the last 30d.
     * @type {string}
     * @memberof StatsData
     */
    'swapCount30d': string;
    /**
     * Int64(e8), total volume of swaps (including synths) denoted in Rune since beginning. 
     * @type {string}
     * @memberof StatsData
     */
    'swapVolume': string;
    /**
     * Int64(e8), amount of native rune switched from erc20 or BEPSwap rune.
     * @type {string}
     * @memberof StatsData
     */
    'switchedRune': string;
    /**
     * Int64, number of swaps from Synth to Rune since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'synthBurnCount': string;
    /**
     * Int64, number of swaps from Rune to Synth since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'synthMintCount': string;
    /**
     * Int64, number of swaps from Rune to Asset since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'toAssetCount': string;
    /**
     * Int64, number of swaps from Asset to Rune since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'toRuneCount': string;
    /**
     * Deprecated, it\'s always 0.
     * @type {string}
     * @memberof StatsData
     */
    'uniqueSwapperCount': string;
    /**
     * Int64, number of withdraws since beginning.
     * @type {string}
     * @memberof StatsData
     */
    'withdrawCount': string;
    /**
     * Int64(e8), total of withdraws since beginning. 
     * @type {string}
     * @memberof StatsData
     */
    'withdrawVolume': string;
}
/**
 * 
 * @export
 * @interface SwapHistory
 */
export interface SwapHistory {
    /**
     * 
     * @type {SwapHistoryIntervals}
     * @memberof SwapHistory
     */
    'intervals': SwapHistoryIntervals;
    /**
     * 
     * @type {SwapHistoryItem}
     * @memberof SwapHistory
     */
    'meta': SwapHistoryItem;
}
/**
 * 
 * @export
 * @interface SwapHistoryIntervals
 */
export interface SwapHistoryIntervals extends Array<SwapHistoryItem> {
}
/**
 * 
 * @export
 * @interface SwapHistoryItem
 */
export interface SwapHistoryItem {
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the weighted average (by count) of toAssetAverageSlip, toRuneAverageSlip, synthMintAverageSlip, synthRedeemAverageSlip. Big swaps have the same weight as small swaps. 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'averageSlip': string;
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'endTime': string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'runePriceUSD': string;
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'startTime': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from rune to synthetic asset. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthMintAverageSlip': string;
    /**
     * Int64, count of rune to synthetic asset swaps
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthMintCount': string;
    /**
     * Int64(e8), the fees collected from swaps from rune to synthetic asset (in rune) 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthMintFees': string;
    /**
     * Int64(e8), volume of swaps from rune to synthetic asset denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthMintVolume': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from synthetic asset to rune. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthRedeemAverageSlip': string;
    /**
     * Int64, count of synthetic asset to rune swaps
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthRedeemCount': string;
    /**
     * Int64(e8), the fees collected from swaps from synthetic asset to rune (in rune) 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthRedeemFees': string;
    /**
     * Int64(e8), volume of swaps from synthetic asset to rune denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'synthRedeemVolume': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from rune to asset. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toAssetAverageSlip': string;
    /**
     * Int64, count of swaps from rune to asset
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toAssetCount': string;
    /**
     * Int64(e8), the fees collected from swaps from rune to asset (in rune)
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toAssetFees': string;
    /**
     * Int64(e8), volume of swaps from rune to asset denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toAssetVolume': string;
    /**
     * Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps from asset to rune. Big swaps have the same weight as small swaps 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toRuneAverageSlip': string;
    /**
     * Int64, count of swaps from asset to rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toRuneCount': string;
    /**
     * Int64(e8), the fees collected from swaps from asset to rune (in rune)
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toRuneFees': string;
    /**
     * Int64(e8), volume of swaps from asset to rune denoted in rune
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'toRuneVolume': string;
    /**
     * Int64, toAssetCount + toRuneCount + synthMintCount + synthRedeemCount
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'totalCount': string;
    /**
     * Int64(e8), toAssetFees + toRuneFees + synthMintFees + synthRedeemFees
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'totalFees': string;
    /**
     * Int64(e8), toAssetVolume + toRuneVolume + synthMintVolume + synthRedeemVolume (denoted in rune) 
     * @type {string}
     * @memberof SwapHistoryItem
     */
    'totalVolume': string;
}
/**
 * 
 * @export
 * @interface SwapMetadata
 */
export interface SwapMetadata {
    /**
     * Affiliate fee address of the swap, empty if fee swap
     * @type {string}
     * @memberof SwapMetadata
     */
    'affiliateAddress': string;
    /**
     * Int64 (Basis points, 0-1000, where 1000=10%)
     * @type {string}
     * @memberof SwapMetadata
     */
    'affiliateFee': string;
    /**
     * Int64(e8), RUNE amount charged as swap liquidity fee
     * @type {string}
     * @memberof SwapMetadata
     */
    'liquidityFee': string;
    /**
     * Transaction memo of the swap action
     * @type {string}
     * @memberof SwapMetadata
     */
    'memo': string;
    /**
     * 
     * @type {NetworkFees}
     * @memberof SwapMetadata
     */
    'networkFees': NetworkFees;
    /**
     * Int64 (Basis points, 0-10000, where 10000=100%), swap slip percentage
     * @type {string}
     * @memberof SwapMetadata
     */
    'swapSlip': string;
    /**
     * Int64(e8), minimum output amount specified for the swap
     * @type {string}
     * @memberof SwapMetadata
     */
    'swapTarget': string;
}
/**
 * 
 * @export
 * @interface THORNameDetails
 */
export interface THORNameDetails {
    /**
     * List details of all chains and their addresses for a given THORName
     * @type {Array<THORNameEntry>}
     * @memberof THORNameDetails
     */
    'entries': Array<THORNameEntry>;
    /**
     * Int64, THORChain block height in which THORName expires
     * @type {string}
     * @memberof THORNameDetails
     */
    'expire': string;
    /**
     * owner\'s THOR address
     * @type {string}
     * @memberof THORNameDetails
     */
    'owner': string;
}
/**
 * 
 * @export
 * @interface THORNameEntry
 */
export interface THORNameEntry {
    /**
     * address on blockchain
     * @type {string}
     * @memberof THORNameEntry
     */
    'address': string;
    /**
     * blockchain
     * @type {string}
     * @memberof THORNameEntry
     */
    'chain': string;
}
/**
 * 
 * @export
 * @interface TVLHistory
 */
export interface TVLHistory {
    /**
     * 
     * @type {TVLHistoryIntervals}
     * @memberof TVLHistory
     */
    'intervals': TVLHistoryIntervals;
    /**
     * 
     * @type {TVLHistoryItem}
     * @memberof TVLHistory
     */
    'meta': TVLHistoryItem;
}
/**
 * 
 * @export
 * @interface TVLHistoryIntervals
 */
export interface TVLHistoryIntervals extends Array<TVLHistoryItem> {
}
/**
 * 
 * @export
 * @interface TVLHistoryItem
 */
export interface TVLHistoryItem {
    /**
     * Int64, The end time of bucket in unix timestamp
     * @type {string}
     * @memberof TVLHistoryItem
     */
    'endTime': string;
    /**
     * Float, the price of Rune based on the deepest USD pool at the end of the interval. 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    'runePriceUSD': string;
    /**
     * Int64, The beginning time of bucket in unix timestamp
     * @type {string}
     * @memberof TVLHistoryItem
     */
    'startTime': string;
    /**
     * Int64(e8), the total amount of bonds (both active and standby) at the end of the interval 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    'totalValueBonded'?: string;
    /**
     * Int64(e8), total value locked in the chain (in rune) This equals `totalPooledValue + totalBondedValue`, as it combines the liquidity pools and bonds of the nodes. 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    'totalValueLocked'?: string;
    /**
     * Int64(e8) in rune, the total pooled value (both assets and rune) in all of the pools at the end of the interval. Note: this is twice the aggregate Rune depth of all pools. 
     * @type {string}
     * @memberof TVLHistoryItem
     */
    'totalValuePooled': string;
}
/**
 * Transaction data
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Sender address
     * @type {string}
     * @memberof Transaction
     */
    'address': string;
    /**
     * 
     * @type {Coins}
     * @memberof Transaction
     */
    'coins': Coins;
    /**
     * Transaction id hash. Some transactions (such as outbound transactions made in the native asset) may have a zero value. 
     * @type {string}
     * @memberof Transaction
     */
    'txID': string;
}
/**
 * 
 * @export
 * @interface WithdrawMetadata
 */
export interface WithdrawMetadata {
    /**
     * Decimal (-1.0 <=> 1.0), indicates how assymetrical the withdrawal was. 0 means totally symetrical 
     * @type {string}
     * @memberof WithdrawMetadata
     */
    'asymmetry': string;
    /**
     * Int64 (Basis points, 0-10000, where 10000=100%), percentage of total pool ownership withdrawn 
     * @type {string}
     * @memberof WithdrawMetadata
     */
    'basisPoints': string;
    /**
     * Int64, additional Rune payed out because of impermanent loss protection
     * @type {string}
     * @memberof WithdrawMetadata
     */
    'impermanentLossProtection': string;
    /**
     * Int64, amount of liquidity units removed from the member as result of the withdrawal 
     * @type {string}
     * @memberof WithdrawMetadata
     */
    'liquidityUnits': string;
    /**
     * Transaction memo of the withdraw action
     * @type {string}
     * @memberof WithdrawMetadata
     */
    'memo': string;
    /**
     * 
     * @type {NetworkFees}
     * @memberof WithdrawMetadata
     */
    'networkFees': NetworkFees;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
         * @param {string} [affiliate] Affiliate address of the action (swap) 
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: async (address?: string, txid?: string, asset?: string, type?: string, affiliate?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (affiliate !== undefined) {
                localVarQueryParameter['affiliate'] = affiliate;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it. 
         * @summary Current balance for an address
         * @param {string} address Rune address.
         * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
         * @param {number} [height] Block height (if provided, timestamp must not be provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance: async (address: string, timestamp?: number, height?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getBalance', 'address', address)
            const localVarPath = `/v2/balance/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns block height and timestamp for each churn.
         * @summary Churns List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChurns: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/churns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory: async (pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pool' is not null or undefined
            assertParamExists('getDepthHistory', 'pool', pool)
            const localVarPath = `/v2/history/depths/{pool}`
                .replace(`{${"pool"}}`, encodeURIComponent(String(pool)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory: async (interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated. 
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object with known pools and their statuses
         * @summary Known Pools List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnownPools: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/knownpools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory: async (pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/liquidity_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address. 
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getMemberDetail', 'address', address)
            const localVarPath = `/v2/member/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses: async (pool?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY. 
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPool', 'asset', asset)
            const localVarPath = `/v2/pool/{asset}`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats: async (asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPoolStats', 'asset', asset)
            const localVarPath = `/v2/pool/{asset}/stats`
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: async (status?: 'available' | 'staged' | 'suspended', period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory: async (pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/swaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getTHORNameDetail', 'name', name)
            const localVarPath = `/v2/thorname/lookup/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTHORNamesByAddress', 'address', address)
            const localVarPath = `/v2/thorname/rlookup/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames. 
         * @summary THORName owner
         * @param {string} address Address which owns a THORName.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesOwnerByAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getTHORNamesOwnerByAddress', 'address', address)
            const localVarPath = `/v2/thorname/owner/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory: async (interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/history/tvl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Historically Midgard acted as a caching proxy for a subset of the Thornode API endpoints. This functionality has been deprecated since the default configuration for fullnodes has been extended to support caching on these endpoints at the gateway NGINX directly. These endpoints will remain available in Midgard for the time being to facilitate a smooth transition for clients, but please take steps to migrate any client code to reference these directly from the Thornode API https://thornode.ninerealms.com/thorchain/doc/#/. 
         * @summary [Deprecated] Thornode Proxied Endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThornodeProxiedEndpoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/thorchain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
         * @param {string} [affiliate] Affiliate address of the action (swap) 
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActions(address?: string, txid?: string, asset?: string, type?: string, affiliate?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActions(address, txid, asset, type, affiliate, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it. 
         * @summary Current balance for an address
         * @param {string} address Rune address.
         * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
         * @param {number} [height] Block height (if provided, timestamp must not be provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalance(address: string, timestamp?: number, height?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalance(address, timestamp, height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns block height and timestamp for each churn.
         * @summary Churns List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChurns(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Churns>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChurns(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepthHistory(pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepthHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepthHistory(pool, interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarningsHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EarningsHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarningsHistory(interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated. 
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object with known pools and their statuses
         * @summary Known Pools List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKnownPools(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnownPools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKnownPools(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiquidityHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidityHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityHistory(pool, interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address. 
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemberDetail(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemberDetail(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembersAdresses(pool?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMembersAdresses(pool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Nodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY. 
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(asset, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolStats(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolStatsDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolStats(asset, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPools(status?: 'available' | 'staged' | 'suspended', period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(status, period, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwapHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwapHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwapHistory(pool, interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTHORNameDetail(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<THORNameDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTHORNameDetail(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTHORNamesByAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseTHORNames>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTHORNamesByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames. 
         * @summary THORName owner
         * @param {string} address Address which owns a THORName.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTHORNamesOwnerByAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseTHORNames>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTHORNamesOwnerByAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTVLHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TVLHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTVLHistory(interval, count, to, from, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Historically Midgard acted as a caching proxy for a subset of the Thornode API endpoints. This functionality has been deprecated since the default configuration for fullnodes has been extended to support caching on these endpoints at the gateway NGINX directly. These endpoints will remain available in Midgard for the time being to facilitate a smooth transition for clients, but please take steps to migrate any client code to reference these directly from the Thornode API https://thornode.ninerealms.com/thorchain/doc/#/. 
         * @summary [Deprecated] Thornode Proxied Endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThornodeProxiedEndpoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThornodeProxiedEndpoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
         * @summary Actions List
         * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
         * @param {string} [affiliate] Affiliate address of the action (swap) 
         * @param {number} [limit] number of actions returned, default is 50
         * @param {number} [offset] pagination offset, default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(address?: string, txid?: string, asset?: string, type?: string, affiliate?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getActions(address, txid, asset, type, affiliate, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it. 
         * @summary Current balance for an address
         * @param {string} address Rune address.
         * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
         * @param {number} [height] Block height (if provided, timestamp must not be provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalance(address: string, timestamp?: number, height?: number, options?: any): AxiosPromise<Balance> {
            return localVarFp.getBalance(address, timestamp, height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns block height and timestamp for each churn.
         * @summary Churns List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChurns(options?: any): AxiosPromise<Churns> {
            return localVarFp.getChurns(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory(pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<DepthHistory> {
            return localVarFp.getDepthHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<EarningsHistory> {
            return localVarFp.getEarningsHistory(interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated. 
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<Health> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object with known pools and their statuses
         * @summary Known Pools List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnownPools(options?: any): AxiosPromise<KnownPools> {
            return localVarFp.getKnownPools(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<LiquidityHistory> {
            return localVarFp.getLiquidityHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address. 
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail(address: string, options?: any): AxiosPromise<MemberDetails> {
            return localVarFp.getMemberDetail(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses(pool?: string, options?: any): AxiosPromise<Members> {
            return localVarFp.getMembersAdresses(pool, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options?: any): AxiosPromise<Network> {
            return localVarFp.getNetworkData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: any): AxiosPromise<Nodes> {
            return localVarFp.getNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY. 
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: any): AxiosPromise<PoolDetail> {
            return localVarFp.getPool(asset, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: any): AxiosPromise<PoolStatsDetail> {
            return localVarFp.getPoolStats(asset, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status?: 'available' | 'staged' | 'suspended', period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: any): AxiosPromise<PoolDetails> {
            return localVarFp.getPools(status, period, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<StatsData> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<SwapHistory> {
            return localVarFp.getSwapHistory(pool, interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of chains and their addresses associated with the given THORName
         * @summary THORName Details
         * @param {string} name a THORName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNameDetail(name: string, options?: any): AxiosPromise<THORNameDetails> {
            return localVarFp.getTHORNameDetail(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of THORNames associated with the given address
         * @summary Gives a list of THORNames by reverse lookup
         * @param {string} address Address to match THORNames against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesByAddress(address: string, options?: any): AxiosPromise<ReverseTHORNames> {
            return localVarFp.getTHORNamesByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames. 
         * @summary THORName owner
         * @param {string} address Address which owns a THORName.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTHORNamesOwnerByAddress(address: string, options?: any): AxiosPromise<ReverseTHORNames> {
            return localVarFp.getTHORNamesOwnerByAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
         * @summary Total Value Locked History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..400].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVLHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: any): AxiosPromise<TVLHistory> {
            return localVarFp.getTVLHistory(interval, count, to, from, options).then((request) => request(axios, basePath));
        },
        /**
         * Historically Midgard acted as a caching proxy for a subset of the Thornode API endpoints. This functionality has been deprecated since the default configuration for fullnodes has been extended to support caching on these endpoints at the gateway NGINX directly. These endpoints will remain available in Midgard for the time being to facilitate a smooth transition for clients, but please take steps to migrate any client code to reference these directly from the Thornode API https://thornode.ninerealms.com/thorchain/doc/#/. 
         * @summary [Deprecated] Thornode Proxied Endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThornodeProxiedEndpoints(options?: any): AxiosPromise<void> {
            return localVarFp.getThornodeProxiedEndpoints(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions. 
     * @summary Actions List
     * @param {string} [address] Comma separated list. Address of sender or recipient of any in/out transaction related to the action. 
     * @param {string} [txid] ID of any in/out tx related to the action
     * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
     * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund, switch) 
     * @param {string} [affiliate] Affiliate address of the action (swap) 
     * @param {number} [limit] number of actions returned, default is 50
     * @param {number} [offset] pagination offset, default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getActions(address?: string, txid?: string, asset?: string, type?: string, affiliate?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getActions(address, txid, asset, type, affiliate, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all coin amounts of the given address at the specified timestamp or height, or at the latest process block if neither is provided. (Only one of timestamp or height can be specified, not both.)  This endpoint is enabled only if the midgard startup config allows it. 
     * @summary Current balance for an address
     * @param {string} address Rune address.
     * @param {number} [timestamp] Unix timestamp as seconds since 1970 (if provided, height must not be provided)
     * @param {number} [height] Block height (if provided, timestamp must not be provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBalance(address: string, timestamp?: number, height?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBalance(address, timestamp, height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns block height and timestamp for each churn.
     * @summary Churns List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getChurns(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getChurns(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Depth and Price History
     * @param {string} pool Return stats for this single pool.
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDepthHistory(pool: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDepthHistory(pool, interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Earnings History
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEarningsHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEarningsHistory(interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing the health response of the API. Meaning of heights:  lastThorNode - Latest block as reported by ThorNode.  lastFetched - Latest block fetched from ThorNode.  lastCommitted - Latest block commited to the DB but not fully processed yet.  lastAggregated - Latest block fully processed and aggregated. 
     * @summary Health Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealth(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object with known pools and their statuses
     * @summary Known Pools List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getKnownPools(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getKnownPools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Liquidity Changes History
     * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400]
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now 
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLiquidityHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLiquidityHistory(pool, interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of statistics for all the liquidity providers associated with a given member address. 
     * @summary Member Details
     * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMemberDetail(address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMemberDetail(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown. 
     * @summary Members List
     * @param {string} [pool] Return only members present in the pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMembersAdresses(pool?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMembersAdresses(pool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing Network data
     * @summary Network Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNetworkData(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNetworkData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Node public keys and adresses.
     * @summary Nodes List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNodes(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns details of the pool: depths, price, 24h volume, APY. 
     * @summary Details of a Pool
     * @param {string} asset pool name
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which APY is extrapolated. Default is 30d. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPool(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPool(asset, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns. 
     * @summary Pool Statistics
     * @param {string} asset pool name
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPoolStats(asset: string, period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPoolStats(asset, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing details for a set of pools
     * @summary Pools List
     * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all'} [period] Specifies the base interval from which annualPercentageRate and poolAPY is extrapolated. Default is 30d. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPools(status?: 'available' | 'staged' | 'suspended', period?: '1h' | '24h' | '7d' | '30d' | '90d' | '100d' | '180d' | '365d' | 'all', options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPools(status, period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing global stats for all pools and all transactions
     * @summary Global Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStats(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Swaps History
     * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSwapHistory(pool?: string, interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSwapHistory(pool, interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of chains and their addresses associated with the given THORName
     * @summary THORName Details
     * @param {string} name a THORName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTHORNameDetail(name: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTHORNameDetail(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of THORNames associated with the given address
     * @summary Gives a list of THORNames by reverse lookup
     * @param {string} address Address to match THORNames against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTHORNamesByAddress(address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTHORNamesByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of THORNames owned by the address. The address is not necessarily an associated address for those thornames. 
     * @summary THORName owner
     * @param {string} address Address which owns a THORName.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTHORNamesOwnerByAddress(address: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTHORNamesOwnerByAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns total pool depths, total bonds, and total value locked in specified interval.  Total Value Locked = Total Bonds + 2 * Total Pool Depths  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.  * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..400]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 400 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters 
     * @summary Total Value Locked History
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..400].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now. 
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTVLHistory(interval?: '5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year', count?: number, to?: number, from?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTVLHistory(interval, count, to, from, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Historically Midgard acted as a caching proxy for a subset of the Thornode API endpoints. This functionality has been deprecated since the default configuration for fullnodes has been extended to support caching on these endpoints at the gateway NGINX directly. These endpoints will remain available in Midgard for the time being to facilitate a smooth transition for clients, but please take steps to migrate any client code to reference these directly from the Thornode API https://thornode.ninerealms.com/thorchain/doc/#/. 
     * @summary [Deprecated] Thornode Proxied Endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThornodeProxiedEndpoints(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getThornodeProxiedEndpoints(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpecificationApi - axios parameter creator
 * @export
 */
export const SpecificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecificationApi - functional programming interface
 * @export
 */
export const SpecificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwagger(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwagger(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpecificationApi - factory interface
 * @export
 */
export const SpecificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecificationApiFp(configuration)
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options?: any): AxiosPromise<void> {
            return localVarFp.getDocs(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options?: any): AxiosPromise<void> {
            return localVarFp.getSwagger(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecificationApi - object-oriented interface
 * @export
 * @class SpecificationApi
 * @extends {BaseAPI}
 */
export class SpecificationApi extends BaseAPI {
    /**
     * Swagger/OpenAPI 3.0 specification generated documents.
     * @summary Documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    public getDocs(options?: AxiosRequestConfig) {
        return SpecificationApiFp(this.configuration).getDocs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns human and machine readable swagger/openapi specification
     * @summary Swagger File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    public getSwagger(options?: AxiosRequestConfig) {
        return SpecificationApiFp(this.configuration).getSwagger(options).then((request) => request(this.axios, this.basePath));
    }
}


