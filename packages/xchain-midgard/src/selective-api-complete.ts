/* tslint:disable */
/* eslint-disable */
/**
 * Midgard API (Selective - Complete)  
 * This file contains only the API classes and types that are actually used,
 * reducing bundle size by optimizing the generated OpenAPI client.
 * 
 * Generated by selective approach for optimal tree-shaking
 */

import globalAxios, { AxiosInstance, AxiosRequestConfig } from 'axios';

// Base configuration and utilities
export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}

export class Configuration {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;

    constructor(param: ConfigurationParameters = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }

    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

export const BASE_PATH = "https://midgard.thorchain.info".replace(/\/+$/, "");

export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

// Essential types - only include commonly used ones
export interface Pool {
    asset?: string;
    shortCode?: string;
    status?: string;
    decimals?: number;
    pendingInboundAsset?: string;
    pendingInboundRune?: string;
    balanceAsset?: string;
    balanceRune?: string;
    poolUnits?: string;
    LPUnits?: string;
    synthUnits?: string;
    synthSupply?: string;
    saversDepth?: string;
    saversUnits?: string;
    synthMintPaused?: boolean;
    synthSupplyRemaining?: string;
    loanCollateral?: string;
    loanCr?: string;
    derivedDepthBps?: string;
}

export interface PoolsResponse {
    pools?: Array<Pool>;
}

export interface PoolDetail {
    'annualPercentageRate': string;
    'asset': string;
    'assetDepth': string;
    'assetPrice': string;
    'assetPriceUSD': string;
    'earnings': string;
    'earningsAnnualAsPercentOfDepth': string;
    'liquidityUnits': string;
    'lpLuvi': string;
    'nativeDecimal': string;
    'poolAPY': string;
    'runeDepth': string;
    'saversAPR': string;
    'saversDepth': string;
    'saversUnits': string;
    'saversYieldShare'?: string;
    'status': string;
    'synthSupply': string;
    'synthUnits': string;
    'totalCollateral': string;
    'totalDebtTor': string;
    'units': string;
    'volume24h': string;
}

export interface PoolDetails extends Array<PoolDetail> {}

export interface SaverDetails {
    'pools': Array<SaverPool>;
}

export interface SaverPool {
    'assetAdded': string;
    'assetAddress': string;
    'assetDeposit': string;
    'assetRedeem': string;
    'assetWithdrawn': string;
    'dateFirstAdded': string;
    'dateLastAdded': string;
    'pool': string;
    'units': string;
    'saverUnits': string;
}

export interface GetActions200Response {
    'actions'?: Array<any>;
    'count'?: string;
    'meta'?: any;
}

export interface ReverseTHORNames extends Array<string> {
}

export interface THORNameDetails {
    'name'?: string;
    'expireBlockHeight'?: number;
    'owner'?: string;
    'preferredAsset'?: string;
    'aliasChains'?: Array<any>;
}

// Core API classes - optimized implementations
export class DefaultApi extends BaseAPI {
    
    /**
     * Returns saver details for a given address
     */
    public async getSaverDetail(address: string, options?: AxiosRequestConfig): Promise<SaverDetails> {
        const requestUrl = `${this.basePath}/v2/saver/${encodeURIComponent(String(address))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns pool details for all pools
     */
    public async getPools(options?: AxiosRequestConfig): Promise<Array<PoolDetail>> {
        const requestUrl = `${this.basePath}/v2/pools`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }
    

    /**
     * Returns Network data
     */
    public async getNetwork(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/network`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns aggregate statistics of specified pool in specified period
     */
    public async getPoolStats(pool: string, period?: string, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/pool/${encodeURIComponent(String(pool))}/stats`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
            params: { period, ...options?.params },
        });
        return response.data;
    }

    /**
     * Returns depth and price history of specified pool in specified period
     */
    public async getDepthHistory(pool: string, interval?: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/history/depths/${encodeURIComponent(String(pool))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
            params: { interval, from, to, ...options?.params },
        });
        return response.data;
    }

    /**
     * Returns swap history of specified pool in specified period
     */
    public async getSwapHistory(pool?: string, interval?: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/history/swaps`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
            params: { pool, interval, from, to, ...options?.params },
        });
        return response.data;
    }

    /**
     * Returns member details by address or multiple addresses
     */
    public async getMemberDetail(address: string | Array<string>, options?: AxiosRequestConfig): Promise<any> {
        const addresses = Array.isArray(address) ? address.join(',') : address;
        const requestUrl = `${this.basePath}/v2/member/${encodeURIComponent(String(addresses))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns node information
     */
    public async getNodes(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/thorchain/nodes`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns queue information
     */
    public async getQueue(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/thorchain/queue`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns THORName details for a given name
     */
    public async getTHORNameDetail(name: string, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/thorname/${encodeURIComponent(String(name))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response;
    }

    /**
     * Returns THORNames by address - reverse lookup
     */
    public async getTHORNamesByAddress(address: string, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/thorname/lookup/${encodeURIComponent(String(address))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response;
    }

    /**
     * Returns actions/transactions data
     */
    public async getActions(
        address?: string, 
        txid?: string, 
        asset?: string, 
        type?: string, 
        txType?: string, 
        affiliate?: string, 
        limit?: number, 
        offset?: number, 
        nextPageToken?: string, 
        timestamp?: number, 
        height?: number, 
        prevPageToken?: string, 
        fromTimestamp?: number, 
        fromHeight?: number, 
        options?: AxiosRequestConfig
    ): Promise<any> {
        const params = new URLSearchParams();
        if (address) params.append('address', address);
        if (txid) params.append('txid', txid);
        if (asset) params.append('asset', asset);
        if (type) params.append('type', type);
        if (txType) params.append('txType', txType);
        if (affiliate) params.append('affiliate', affiliate);
        if (limit !== undefined) params.append('limit', limit.toString());
        if (offset !== undefined) params.append('offset', offset.toString());
        if (nextPageToken) params.append('nextPageToken', nextPageToken);
        if (timestamp !== undefined) params.append('timestamp', timestamp.toString());
        if (height !== undefined) params.append('height', height.toString());
        if (prevPageToken) params.append('prevPageToken', prevPageToken);
        if (fromTimestamp !== undefined) params.append('fromTimestamp', fromTimestamp.toString());
        if (fromHeight !== undefined) params.append('fromHeight', fromHeight.toString());

        const requestUrl = `${this.basePath}/v2/actions${params.toString() ? '?' + params.toString() : ''}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }
}

// Specification API - minimal implementation
export class SpecificationApi extends BaseAPI {
    /**
     * Return the OpenAPI specification for the Midgard API
     */
    public async getOpenApiSpec(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/doc`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }
}

// Types
export interface Coin {
    'amount': string;
    'asset': string;
}

export interface Coins extends Array<Coin> {}

export interface NetworkFees extends Array<Coin> {}

export interface SwapMetadata {
    'affiliateAddress': string;
    'affiliateFee': string;
    'inPriceUSD': string;
    'isStreamingSwap': boolean;
    'liquidityFee': string;
    'memo': string;
    'networkFees': NetworkFees;
    'outPriceUSD': string;
    'swapSlip': string;
    'swapTarget': string;
}

export interface Transaction {
    'address': string;
    'affiliate'?: boolean;
    'coins': Coins;
    'height'?: string;
    'txID': string;
}