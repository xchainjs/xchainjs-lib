/* tslint:disable */
/* eslint-disable */
/**
 * Midgard API (Selective - Complete)  
 * This file contains only the API classes and types that are actually used,
 * reducing bundle size by optimizing the generated OpenAPI client.
 * 
 * Generated by selective approach for optimal tree-shaking
 */

import globalAxios, { AxiosInstance, AxiosRequestConfig } from 'axios';

// Base configuration and utilities
export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}

export class Configuration {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;

    constructor(param: ConfigurationParameters = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }

    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

export const BASE_PATH = "https://midgard.mayachain.info".replace(/\/+$/, "");

export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

// Essential types - only include commonly used ones
export interface Pool {
    asset?: string;
    shortCode?: string;
    status?: string;
    decimals?: number;
    pendingInboundAsset?: string;
    pendingInboundRune?: string;
    balanceAsset?: string;
    balanceRune?: string;
    poolUnits?: string;
    LPUnits?: string;
    synthUnits?: string;
    synthSupply?: string;
    saversDepth?: string;
    saversUnits?: string;
    synthMintPaused?: boolean;
    synthSupplyRemaining?: string;
    loanCollateral?: string;
    loanCr?: string;
    derivedDepthBps?: string;
}

export interface PoolsResponse {
    pools?: Array<Pool>;
}

export interface PoolDetail {
    'annualPercentageRate': string;
    'asset': string;
    'assetDepth': string;
    'assetPrice': string;
    'assetPriceUSD': string;
    'earnings': string;
    'earningsAnnualAsPercentOfDepth': string;
    'liquidityUnits': string;
    'lpLuvi': string;
    'nativeDecimal': string;
    'poolAPY': string;
    'runeDepth': string;
    'saversAPR': string;
    'saversDepth': string;
    'saversUnits': string;
    'saversYieldShare'?: string;
    'status': string;
    'synthSupply': string;
    'synthUnits': string;
    'totalCollateral': string;
    'totalDebtTor': string;
    'units': string;
    'volume24h': string;
}

export interface PoolDetails extends Array<PoolDetail> {}

export interface SaverDetails {
    'pools': Array<SaverPool>;
}

export interface SaverPool {
    'assetAdded': string;
    'assetAddress': string;
    'assetDeposit': string;
    'assetRedeem': string;
    'assetWithdrawn': string;
    'dateFirstAdded': string;
    'dateLastAdded': string;
    'pool': string;
    'units': string;
    'saverUnits': string;
}

// Additional types needed by mayamidgard-query package
export interface Health {
    'database'?: boolean;
    'scannerHeight'?: number;
    'catching_up'?: boolean;
    'in_sync'?: boolean;
    'version'?: string;
    'cacheStatus'?: string;
    'midgardReleased'?: string;
    'scannerError'?: string;
}

export interface MemberDetails {
    'pools'?: Array<any>;
    'runeAdded'?: string;
    'runeWithdrawn'?: string;
    'runeValue'?: string;
    'assetAdded'?: string;
    'assetWithdrawn'?: string;
    'assetValue'?: string;
    'poolStats'?: any;
    'MAYANameDetails'?: THORNameDetails;
}

export interface GetActions200Response {
    'actions'?: Array<any>;
    'count'?: string;
    'meta'?: any;
}

export interface ReverseTHORNames extends Array<string> {
}

export interface THORNameDetails {
    'entries': Array<THORNameEntry>;
    'expire': string;
    'owner': string;
}

export interface THORNameEntry {
    'chain': string;
    'address': string;
}

export interface Action {
    'date': string;
    'height': string;
    'in': Array<Transaction>;
    'metadata': Metadata;
    'out': Array<Transaction>;
    'pools': Array<string>;
    'status': string;
    'type': string;
}

export interface Transaction {
    'address'?: string;
    'coins'?: Array<any>;
    'txID'?: string;
}

export interface Metadata {
    'addLiquidity'?: any;
    'refund'?: any;
    'swap'?: SwapMetadata;
    'withdraw'?: any;
}

export interface SwapMetadata {
    'affiliateAddress': string;
    'affiliateFee': string;
    'inPriceUSD': string;
    'isStreamingSwap': boolean;
    'liquidityFee': string;
    'memo': string;
    'networkFees': Array<any>;
    'outPriceUSD': string;
    'swapSlip': string;
    'swapTarget': string;
}

export interface PoolStatsDetail {
    'addAssetLiquidityVolume'?: string;
    'addLiquidityCount'?: string;
    'addLiquidityVolume'?: string;
    'addRuneLiquidityVolume'?: string;
    'asset'?: string;
    'assetDepth'?: string;
    'assetPrice'?: string;
    'assetPriceUSD'?: string;
}

// Core API classes - optimized implementations
export class DefaultApi extends BaseAPI {
    
    /**
     * Returns statistics of pools saved in database
     */
    public async getPools(options?: AxiosRequestConfig): Promise<Array<PoolDetail>> {
        const requestUrl = `${this.basePath}/v2/pools`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns Network data
     */
    public async getNetwork(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/network`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }


    /**
     * Returns depth and price history of specified pool in specified period
     */
    public async getDepthHistory(pool: string, interval?: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/history/depths/${encodeURIComponent(String(pool))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
            params: { interval, from, to, ...options?.params },
        });
        return response.data;
    }

    /**
     * Returns swap history of specified pool in specified period
     */
    public async getSwapHistory(pool?: string, interval?: string, from?: number, to?: number, options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/history/swaps`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
            params: { pool, interval, from, to, ...options?.params },
        });
        return response.data;
    }


    /**
     * Returns node information
     */
    public async getNodes(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/mayachain/nodes`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns queue information
     */
    public async getQueue(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/mayachain/queue`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns health information
     */
    public async getHealth(options?: AxiosRequestConfig): Promise<Health> {
        const requestUrl = `${this.basePath}/v2/health`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns THORName details by name
     */
    public async getTHORNameDetail(name: string, options?: AxiosRequestConfig): Promise<THORNameDetails> {
        const requestUrl = `${this.basePath}/v2/mayachain/thorname/${encodeURIComponent(String(name))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns THORNames by address (reverse lookup)
     */
    public async getTHORNamesByAddress(address: string, options?: AxiosRequestConfig): Promise<ReverseTHORNames> {
        const requestUrl = `${this.basePath}/v2/mayachain/reverse_lookup/${encodeURIComponent(String(address))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns member details for a given address
     */
    public async getMemberDetail(address: string, options?: AxiosRequestConfig): Promise<MemberDetails> {
        const requestUrl = `${this.basePath}/v2/member/${encodeURIComponent(String(address))}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns pool statistics for a given asset
     */
    public async getPoolStats(asset: string, options?: AxiosRequestConfig): Promise<PoolStatsDetail> {
        const requestUrl = `${this.basePath}/v2/pool/${encodeURIComponent(String(asset))}/stats`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }

    /**
     * Returns actions with optional filtering
     */
    public async getActions(
        address?: string,
        txid?: string, 
        asset?: string,
        type?: string,
        affiliate?: string,
        limit?: number,
        offset?: number,
        nextPageToken?: string,
        timestamp?: number,
        height?: number,
        prevPageToken?: string,
        fromTimestamp?: number,
        fromHeight?: number,
        options?: AxiosRequestConfig
    ): Promise<GetActions200Response> {
        const params = new URLSearchParams();
        if (address) params.append('address', address);
        if (txid) params.append('txid', txid);
        if (asset) params.append('asset', asset);
        if (type) params.append('type', type);
        if (affiliate) params.append('affiliate', affiliate);
        if (limit) params.append('limit', limit.toString());
        if (offset) params.append('offset', offset.toString());
        if (nextPageToken) params.append('nextPageToken', nextPageToken);
        if (timestamp) params.append('timestamp', timestamp.toString());
        if (height) params.append('height', height.toString());
        if (prevPageToken) params.append('prevPageToken', prevPageToken);
        if (fromTimestamp) params.append('fromTimestamp', fromTimestamp.toString());
        if (fromHeight) params.append('fromHeight', fromHeight.toString());

        const requestUrl = `${this.basePath}/v2/actions${params.toString() ? '?' + params.toString() : ''}`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }
}

// Specification API - minimal implementation
export class SpecificationApi extends BaseAPI {
    /**
     * Return the OpenAPI specification for the Midgard API
     */
    public async getOpenApiSpec(options?: AxiosRequestConfig): Promise<any> {
        const requestUrl = `${this.basePath}/v2/doc`;
        const response = await this.axios.get(requestUrl, {
            ...this.configuration?.baseOptions,
            ...options,
        });
        return response.data;
    }
}